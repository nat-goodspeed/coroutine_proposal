\abschnitt{Discussion}
N4397\cite{N4397} describes \ectx as a mechanism to implement stackful context
switching (for instance coroutines). Each context owns its own side context.\\
How can this formalism be used to express \emph{stackless} as well
\emph{stackful} execution contexts? The answer is the concept of
\emph{suspend-by-calling}.

\uabschnitt{Calling convention}
The calling convetion is a scheme, part of the ABI\footnote{Application Binary
Interfaces; an executable must be conform to, in order to be executable in the
specified execution environment}, describing how a subroutine has to be called.
This includes parameter list, return address, \emph{stack layout} and
cleanup.\\
Some calling conventions (for instance x86 architecure) require that data like
\emph{parameter list} as well as \emph{return address} are stored on the
stack before the subroutine is invoked. Other calling conventions of other
architectures (for instance ARM's AAPCS) do not have this restriction
\footnote{AAPCS64: parameters in registers R0-R7/V0-V7, return address in link
register LR}, e.g. using the stack is minimized\footnote{of course a long
parameters list requires the stack; but this is negibile as shown in the text}
\newline
The proposed syntax for stackless and stackful context switching requires that
the stack is clean, e.g. no parameter list and no return address, remain on the
stack if a context switch happens. This is a guarantee of the requirement that
a coroutien can outlive the context is was created in.\\
In other words, that parts that would remain on the callers stack must be
preserved and restored by a context switch (member function \ectxop). This also
a consequence by the \emph{suspend-by-calling} concept. Previous proposals like
N4134\cite{N4134} describe a \emph{suspend-by-returning} mechanism, e.g. the
coroutine is suspended by calling \yield etc. (for resumable functions a return
value transformation happens -> return value is substituded by a future-like
object).

\uabschnitt{Suspend-by-calling}
requires symmetric transfer of execution control
one place for mainpulation (stack and cpature record)
requires first-calsss object
enables broader range of control flow as asymmetric -> (oneshot) sift/resume operations
\paragraph*{Prolog}
\paragraph*{Epilog}
multiple invokations and free flow of stackless coroutines
at source level no modifications required - only implementation (rpolog/epilog) is modified
