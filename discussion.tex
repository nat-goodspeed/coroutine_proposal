\abschnitt{Discussion}
\uabschnitt{Side stack/activation frame}
Resumable functions as well as resumable lambdas require storage for local
(stack) variables and the control block (preserved CPU register). The compiler
analyzes the function body, determines the required size and allocates the
activation frame.
\cppf{N4134/fib.cpp}
In the example of calculating Fibonacci numbers using a resumable function
(simple function body, no subroutine is called), the compiler reserves space
(activation frame) for local variables \cpp{n}, \cpp{a}, \cpp{b} and \cpp{next}.
Those variables are not accessed via the stack pointer as common in ordinary
functions - instead he compiler generates inside \cpp{fib()} assembler code,
that references the local variables by re-useing another CPU register. The
application stack is not used and the stack pointer is not changed.\\
\newline
Each stackful execution context owns a stack, e.g. the side stack is assigned to
the stack pointer. The control block (CPU register) is pushed to/ poped from the
side stack.
\cppf{fib.cpp}
In the case of calculating the Fibonacci numbers using a stackful execution
context, the compiler stores the local variables \cpp{n}, \cpp{a}, \cpp{b} and
\cpp{next} on the side stack. The local variables are accessed via the stack
pointer.
\paragraph*{Summary}
For simple function bodies, stackless and stackful context switching has similar
memory requirements. A stackful and a stackless context switch differ only in
how local data are accessed - a stackful execution context uses its stack
pointer (pointing to the side stack) while a stackless resumable function
re-uses another CPU register to point to the activation frame holding its local
variables. In both cases the application stack remains unchanged.

\uabschnitt{Calling subroutines}
Resumable functions/lambdas share the same application stack, e.g. the stack
pointer is unchanged and holds an address from the application stack (function
\main or thread).\\
If a subroutine is invoked inside the body of a resumable function/lambda, then
a stack frame is allocated on the application stack (not on the activation
frame)! As a consequence stack frames of subroutines have to be removed from the
application stack before the resumable function/lambda yields back to its caller
(suspend to its resumption point). Otherwise the stack frames would be corrupted
(overwritten) by other code using the application stack. Hence a yield from
nested call stack is not permitted.\\
The benefit of stackless resumable context switching consists in sharing the
application stack because a resumable function/lambda does not need to allocate
memory for the stack frames of subroutines, invoked inside the body of that
resumable function/lambda.
\cppf{N4244/simple.cpp}
The stackless resumable lambda \textit{l} in the example above stores variable 
\textit{j} in its activation frame (storage of capture list). The stack frames of
\cpp{std::printf()} are allocated on the application stack and will be removed
before \yield is executed.
\newline
Of course even stackless resumable functions/lambdas might fail if the available
stack space is exceeded by subroutines (for instance recursive invocation).\\
\newline
In the context of stackful context switching each execution context owns a
distinct side stack. In contrast to resumable functions/lambdas the side stack
is assigned to the stack pointer (e.g. the stack pointer has to be exchanged
during each context switch).\\
As a consequence, all local variables and all stack frames of subroutines are
allocated on the side stack. Hence each stackful execution context requires
enough memory to hold the stack frames of the longest call chain of subroutines.
Therefore stackful context switching has a higher memory footprint than
stackless resumable functions/lambdas (but this applies only in the context of
calling subroutines).\\
On the other side, it is benefital to use side stacks because the stack frames
of subroutines remain intact while the execution context gets suspended. This is
the reason why stackful context switching permits yielding from nested stack
frames.
\cppf{simple.cpp}
Variable \textit{l1} is passed to stackful execution context \textit{l2} via
the capture list of \textit{l2}. The stack frames of \cpp{std::printf()} are
allocated on the side stack that \textit{l2} owns.
\paragraph*{Summary}
Subroutines called inside stackless resumable functions/lambdas share the
application stack and do not use space on the activation frame. Hence resumable
functions/lambdas have in this scenario a lower memory requirement than stackful
context switching. This introduces the constraint that stack frames of
subroutines have to be removed from the application stack before the resumable
function/lambda yields back to its resumption point (point in code were it was
resumed/invoked). Hence, suspending a resumable function/lambda from nested call
stack is not possible.\\
Stackful context switching permits stack frames of subroutines on the side stack
while the execution context is suspended.

\uabschnitt{Resume/suspend operations}
Resumable functions/lambdas (as proposed in N4134 and N4244) provide two
operations for context switching (asymmetric transfer of execution control).
One operation to resume (\cpp{operator()}) and one operation to suspend the
context (\yield inside the function body). The caller and the resumable
function/lambda are coupled, e.g. a resumable function/lambda can only jump back
to the point in the code where it was resumed.\\
\newline
For N resumable functions/lambdas 2*N context switches are required.\\
This is sufficient in the case of generators but in the context of cooperative
multitasking it is inefficient.
\imgc{asymm.pdf}
In contrast to resumable functions/lambdas the proposed stackful execution
context (\ectx) provides only one operation to resume/suspend the context
(\ectxop). The execution control is directly transferred from one
execution context to another (symmetric transfer-mechanism) - no jump back to
the caller. This enables a much more efficient implementation of cooperative
multitasking (no additional context switch back to caller) as well as the
implementation of generators. As an consequence, the next execution context has
to be explicitly specified.\\
\newline
Resuming N instances of \ectx takes N+1 context switches.
\imgc{symm.pdf}
\paragraph*{Summary}
Stackful context switching as proposed in this paper, provides only one
resume/suspend operation (symmetric transfer of execution control). In the use
case of cooperative multitasking this is more efficient (less context switches
required).

\uabschnitt{Passing data}
Because of the asymmetric resume/suspend operations of N4134 and N4244, both
proposals apply well to generator-examples, e.g. returning data from the
resumable function/lambda (for instance using \yield).\\
Passing data into the body of resumable functions (N4123) requires helper
classes like \channel.
\cppf{N4134/channel.cpp}
For resumable lambdas of N4244 the member function \rlwanted has to be used.
\cppf{N4244/wanted.cpp}
In both cases the way how data have to be passed into the body is not intuitive
and provides some problems how returned values should be accessed. For instance
multiple parameters must be transported with an container (\tuple) or via
multiple invocations of \rlwanted (including additional context switches).\\
\newline
An alternative would be not directly support parameter passing in the API.\\
During the use of \cpp{execution_context} from boost.context\cite{bcontext} a
common pattern was to pass lambdas to the execution context and use the capture
list to pass data into and return data from the body. Exceptions are transferred
via a reference of \excpt and parameters (input/output) are accessed via
captured addresses (reference or pointer).
\cppf{param.cpp}
Class \cpp{X} (rudimentary coroutine) demonstrates how input and output
parameter are transferred between a context switch. Member variable
\textit{callee\_} represents a new execution context and captures the
\textit{this}-pointer of \cpp{X}. The body converts a integer variable (input)
into a string (output). Exceptions, thrown by the conversion, are transported
via \textit{exptr\_}.

\uabschnitt{Summary \textit{stackless} resumable function/lambda}
\begin{itemize}
    \item   for each resumable function/lambda an activation frame is allocated
    \item   activation frame (local variables, control block) and stack are
            distinct
    \item   application stack is shared between resumable functions/lambdas
    \item   N4134/N4244: asymmetric context switching -> tight coupling between
            caller and invoker
    \item   returning data from resumable function/lambda via \yield etc.
    \item   no intuitive passing data into body of resumable function/lambda
    \item   suspend operation from nested call stack is not permitted
\end{itemize}

\uabschnitt{Summary \textit{stackful} execution context}
\begin{itemize}
    \item   each stackful execution context owns a side stack (fixed-size or
            linked stack)
    \item   activation frame and stack are the same, not distinct
    \item   stack is not shared between different instances of \ectx
    \item   symmetric context switching -> no coupling between caller and
            invoker (more efficient in the context of cooperative multitasking)
    \item   passing data via lambda captures
    \item   suspend operation from nested call stack is permitted
\end{itemize}
Higher level frameworks based on \ectx can realize more sophisticated APIs
(like range based for etc.) - as an example the API of N3985\cite{N3985} is
implemented in boost.coroutine2\cite{bcoroutine2} based on
\cpp{execution_context}.
\cppf{N3985/fib.cpp}
