\abschnitt{Discussion}
N4397\cite{N4397} describes \ectx as a mechanism to implement stackful context
switching (for instance coroutines). Each context owns its own side stack.\\
How can this formalism be used to express \emph{stackless} as well as
\emph{stackful} execution contexts? The answer is the concept of
\emph{suspend-by-calling}.

\uabschnitt{Calling convention}
A calling convention is a scheme, part of the ABI\footnote{Application Binary
Interfaces; an executable must be conform to, in order to be executable in the
specified execution environment}, that describes how a subroutine must be
called. This includes parameter list, return address, \emph{stack layout} and
cleanup.\\
Some calling conventions (for instance x86 architecture) require that data like
\emph{parameter list} as well as \emph{return address} are stored on the caller's
stack before the subroutine is invoked. Other calling conventions of other
architectures (for instance ARM's AAPCS) do not have this constraint
\footnote{AAPCS64: parameters in registers R0-R7/V0-V7, return address in link
register LR}, e.g. stack consumption is minimized\footnote{of course a long
parameter list requires the stack; but this is negligible as shown in the text}
\newline
The proposed syntax for stackless and stackful context switching requires that
the stack is clean: no parameter list and no return address may remain on the
caller's stack when a context switch happens. This is required since a
coroutine can outlive the context in which it was created.\\
In other words, those parts that would remain on the caller's stack must be
preserved and restored by a context switch (member function \ectxop). This
supports the \emph{suspend-by-calling} concept. Previous proposals like
N4134\cite{N4134} describe a \emph{suspend-by-returning} mechanism, i.e. the
coroutine is suspended by calling \yield etc. (for resumable functions a return
value transformation happens -- the return value is substituted by a future-like
object).

\uabschnitt{Suspend-by-calling}
\emph{suspend-by-calling} requires a symmetric transfer of execution control
as well as first-class objects in order to specify the next context to be
resumed.\\
This enables an arbitrary flow of context switches providing a broad range of
control flows (for instance \emph{delimited continuations}).\\
As a consequence the part belonging to the called function on the caller's stack
must be popped and preserved in the caller's \emph{capture record}. The caller
context suspends by calling\\
\ectxop of another execution context. Other execution contexts are able to use
the stack in the meanwhile. If the suspended context is resumed, the preserved
data are pushed to the stack and execution returns from \ectxop.

\paragraph*{Prologue}
The prologue of \ectxop updates the capture record (CPU registers) and pops
some parts (part of callee's stack frame) from caller's stack and preserves the
data into caller's capture record too.

\paragraph*{Epilogue}
If the context (caller context from above) is resumed, the \emph{epilogue} of\\
\ectxop loads the capture record and pushes callee's partial stack frame on
caller's stack. The calling convention remains intact, and the code which
called\\
\ectxop can not distinguish between an ordinary function and a context switch.
It's completely transparent to the caller.

\paragraph*{Flow of control}
Because \ectx uses a symmetric execution control transfer mechanism, the flow
of control can be arbitrary.
\cppf{N4398/cycle}
As shown in the example, the contexts of \emph{ctx1}, \emph{ctx2} and
\emph{ctx3} form a cycle of flow of control.
\graphc{cycle}
The cycle is started by calling \cpp{ctx3()} from the main context
(\emph{$ctx_m$}, created on start-up). Context \emph{$ctx_3$} starts
\emph{$ctx_2$} while \emph{$ctx_2$} resumes \emph{$ctx_1$}. Context
\emph{$ctx_1$} is suspended by resuming \emph{$ctx_3$} with \cpp{(*other)()}.
Function \cpp{ctx2()} returns in \emph{$ctx_3$} and \cpp{ctx1()} next resumes
\emph{$ctx_1$}. Context \emph{$ctx_1$} terminates after returning from
\cpp{(*other)()}.\\
After termination of \emph{$ctx_1$}, \emph{$ctx_3$} is resumed because it has
become the parent context of \emph{$ctx_1$} (by calling \cpp{ctx1()}). As
\emph{$ctx_3$} terminates, the main context \emph{$ctx_m$} is resumed (return
from \cpp{ctx3()}).

\uabschnitt{Stackless and stackful}
The compiler allocates for a \emph{stackless context} only one, suitable sized,
capture record and for a \emph{stackful context} a side stack (linked stack,
e.g. non-contiguous, growing on demand).\\
In order to decide what kind of context has to be generated, the compiler has to
analyse the toplevel context function.The following use cases must be
distinguished:
\begin{itemize}
    \item no context switch: generate an ordinary function
    \item context switch at toplevel: create a \emph{stackless} context
    \item in all other cases: generate a \emph{stackful} context
\end{itemize}
\cppf{N4398/fibonacci}
In other words, if \ectxop is called inside the body of the toplevel context
function (as shown in Fibonacci example above) a \emph{stackless} context is
sufficient.
\cppf{N4398/parser}
Calling a context switch from a nested call stack requires a \emph{stackful}
context.
