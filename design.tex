\abschnitt{Design Decisions}
This section describes two designs - one with a bidirectional and an alternative
design with undirectionial exchange of data.\\

\subsubsection*{Proposed Design}
\boostcoroutine implements in its interface (version 1) a coroutine with
bidirectional flow of data between \corofunction and caller. The template
argument of \coro is a signature defining passed argument and return types.

\paragraph*{stack-full:}
Each instance of \coro has its own stack.\\
\newline
In contrast to stack-less coroutines allow stack-full coroutines to invoke the
suspend operation out of arbitrary sub-stackframes enabling \escreops.

\paragraph*{move-only:}
\coro is moveable-only.\\
\newline
If \coro would be copyable then its stack with all the objects allocated on it
are copied too. This could force undefined behaviour if some of this objects are
RAII-classes (manage a resource via RAII pattern). If one of the \coro copies
terminates (unwinds its stack) the RAII-classes releases their managed resources
at destruction.

\paragraph*{clean-up:}
On destruction \coro unwinds its stack.\\
\newline
The implementer is free to deallocate the stack or cache it for future \coro
instances.

\paragraph*{segmented stack:}
\coro must support segmented stacks (growing on demand).\\
\newline
It is not always possible to estimated the required stack size - in most cases
too much memory is allocated (wast of virtual address-space).\\
\newline
At construction \coro starts with a default (minimal) stack size. This minimal
stack size is the maximum of page size and the canonical size for signal stack
(macro SIGSTKSZ on POSIX).\\
\newline
At this time of writing only GCC (4.7)\cite{gccsplit} is known to support segmented
stacks. With version 1.54 \boostcoroutine provides support for segmented stacks.\\
\newline
The destructor of \coro deallocates the associated stack. The implementer is
free to deallocated the stack or to cache it for later usage.

\paragraph*{context switch:}
\coro stores and restores registers according to the underlying ABI on each
context switch.\\
\newline
This includes also the floating point environment as required by the ABI. The
implementer can omit preserving the floating point env if he can predict that
it's safe.\\
\newline
On POSIX systems \coro must not preserve signal masks for performance reasons.\\
\newline
A context switch is done via \coroop.

\paragraph*{start at construction:}
\corofunction is entered upon construction of \coro not upon the first call.\\
\newline
Because \corofunction is entered upon construction of \coro we can check after
returning from the constructor if a result was provided or the \corofunction
has terminated.\\
\corobool returns true if \coro is still valid (\corofunction has not terminated)
and data is available.\\
The iteration stopped if data is no longer generated:
\cppf{corofn_startup.cpp}
Otherwise detecting the completeness of \coro would require an extra context
switch (return from last \coroop and calling return in the \corofunction).\\
This makes the implementation for iterators very hard and \cpp{std::distance}
would return 4 instead of 3 in the example above.\\
\newline
If parameters are required to be passed at the start of \corofunction then those
parameters can be passed via the \coro constructor.

\paragraph*{coroutine-function signature:}
The \corofunction returns \cpp{void} and takes a \coro of inverted signature
as argument.\\
\newline
This design decision makes the code using \coro let look more symmetric.\\
Both, calling code and coroutine function, use an object of type \coro in order
to switch the context and to transfer data.\\
This requires that the template parameter of the coroutine passed as argument
to the \corofunction has an inverted signature, e.g. return types become
arguments and vice versa.
\cppf{corofn_startup.cpp}

\coro in the main code has a signature of \cpp{int(void)} - it returns an
integer from \corofunction.\\
The \coro argument of \corofunction \cpp{f} has therefore a signature of
\cpp{void(int)} - it transfers an integer to caller.\\
\newline
\corofunction must return void, otherwise the user would call\\
\coroop to return values from the \corofunction and \cpp{return} as the
last call which terminates the \corofunction - with the chosen design we have
only one path to exit the \corofunction.
\cppf{corofn_nonvoid.cpp}

\paragraph*{passing parameters:}
Parameters are passed to the \corofunction via\\\coroop.\\
\newline
\coroop accepts arguments as defined in the template arguments in \coro. A
context switch is executed and the passed parameters will be accessible in in
the \corofunction.

\paragraph*{accessing parameters:}
Parameters returned from the \corofunction can be accessed with\\\coroget.\\
\newline
In contrast to single argument in coroutine signature multiple arguments are
returned via \tuple from \coroget.\\
Splitting-up the access of parameters from context switch function enables to
check if \coro is valid after return from \coroop, e.g. \coro has values and
\corofunction has not terminated.
\cppf{access_params.cpp}

\paragraph*{returning parameters:}
Results can be returned by a \corofunction via\\\coroop.\\
\newline
Like passing parameters to the \corofunction the \corofunction can return
results to the caller.\\ This is done by calling the \coroop of the \coro given
as first argument to \corofunction.
\cppf{return_params.cpp}

\paragraph*{output iterator:}
\coro with signature \cpp{T(void)} provide output iterators.
\cppf{output_iterator.cpp}

\paragraph*{input iterator:}
\coro with signature \cpp{void(T)} provide input iterators.

\paragraph*{exceptions:}
An exception thrown inside \corofunction will re-thrown by \coro constructor or
\coroop.


\subsubsection*{Alternative Design}
An alternative to bidirectional data exchange between coroutine and its invoker
would be to split \coro into two unidirectional coroutine types: \pushcoro and
\pullcoro. \boostcoroutine will provide in its interface version 2 \pushcoro and
\pullcoro (probably in boost-1.54). The advantage regarding to a bidirectional
coroutine is the simplified template argument; instead of an signature
\pullcoro and \pushcoro use only one template argument describing the type
which is exchanged between the context switches.
\cppf{alternative_fibonacci.cpp}

\paragraph*{push\_coroutine:}
With \pushcoro you transfer parameters to the \corofunction (push it to). The
class has only one template parameter defining the parameter type pushed to
\corofunction.\\
\newline
In contrast to \coro the \corofunction is entered by the first call to
\pushcoroop instead of the constructor. The interface does not contain
\coroget, e.g. you can not retrieve return values from this kind of coroutine.
\cppf{push_coroutine.cpp}

\paragraph*{pull\_coroutine:}
With \pullcoro you retrieve parameters from the \corofunction (pull it from).
The class has only one template parameter defining the parameter type pulled
from \corofunction.\\
\newline
The \corofunction is entered in the constructor of \corofunction (like \coro).
The interface contains \coroget to retrieve returned values from the
\corofunction.  This kind of coroutine provides only \pullcoroop which
does not transfer parameters to the \corofunction.
\cppf{pull_coroutine.cpp}

\subsubsection*{Other libraries}
\boostcoroutine is a follow-up on \boostcorosum which is unfinished and
not part of the official boost release (development of this library was
stopped).\\
During the boost review process interface of \boostcoroutine was changed and
differ in some parts to \boostcorosum.\\
Mordor\cite{mordor} is another C++ library implementing cooperative multitasking
in order to achieve high I/O performance. The difference to this design is that
this proposal focus on enhanced control flow while Mordor\cite{mordor} abstracts
on the level of tasking (providing a cooperatively scheduled fiber engine).\\
Another design of a task library was published by AT\&T\cite{atnt1989} describing
a tasking system with non-preemptive scheduling.\\
\coro could be used as the basic mechanism for such kind of tasking abstractions.\\

\paragraph*{resumable functions (N3328\cite{n3328}):}
This proposal is a library superset of N3328 - the \resumfn can be implemented
on top of \coro. The proposed coroutine does not require memory allocation for
the future on a switch and does not require language changes (no keywords like
\textit{resumable} and \textit{await}).\\
A working implementation of this proposal is available at \boostcoroutine.\\
As described in section 3.2.5 'Function Prolog' - the body of a \resumfn is
transformed in a switch statement. This is similar to the stackless coroutines
of Python an C\#.\\
\newline
Without stackfulness and first-class semantic some useful execution control
flows cannot be supported (for instance cooperative multitasking,
checkpointing) and the 'same fringe' example would not be easily implementable.
