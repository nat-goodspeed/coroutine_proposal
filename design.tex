\abschnitt{Design}
Class \ectx is derived from the work on boost.context\cite{bcontext} - it
provides a small, basic API, suitable to implement high-level APIs for stackful
coroutines (N3985\cite{N3985}, working implementation
boost.coroutine2\cite{bcoroutine2}) and user-mode threads (executing tasks in a
cooperative multitasking environment, working implementation
boost.fiber\cite{bfiber}).

prolog of \cpp{execution_context::operator()} preserves CPU register set + stack pointer, e.g.
the content of those registers is stored in the associated control block. additionally the
control block of \cpp{*this} is resumed, e.g. the prolog loads the CPU register set and stack pointer
into the CPU.

epilog of \cpp{execution_context::operator()} restores the control block (registers + stack) of
the outer (resumed) context while the instruction in the epilog preserve the control block
of the suspended context.

\uabschnitt{Class \ectx}
Based on the implementation experience with \cpp{execution_context} in
boost.coroutine2\cite{bcoroutine2} and boost.fiber\cite{bfiber}, the author
noticed that \cpp{execution_context} is almost always used together with lambdas
(passed as argument to the constructor of \cpp{execution_context}). Especially
the lambda captures are suitable to transport data between different execution
context's (address of lvalue, reside on stack/heap).\\
Why not construct \ectx with an 'resumable lambda'-like syntax, instead of
passing a lambda as argument? Even if \ectx is constructed like a lambda,
actually it isn't a lambda (it is constructible from \ectxcurrent too).\\
\ectx is more like an handle to a \emph{capture record} of an execution context.
\cppf{N4397/rl1.cpp}
The keyword \resumable together with an hint (attribute) about the type and size
of the side stack tells the compiler to generate a stackful execution context.\\
Because of the symmetric context switching (only one operation transfers the
control of execution) the target context must be explicitly specified.\\
Exchanging data between different execution context's requires the use of lambda
captures.

\uabschnitt{First-class object}
As first-class object the execution context can be stored in a variable or
container.

\uabschnitt{Capture record}
Each instance of \ectx owns a toplevel activation record, the capture record.
The capture record is a special activation record that stores addtional data
like stack pointer, instruction pointer and a link to its parent execution
context. That means that during a execution context switch, the execution state
of the running context is captured and stored in the capture record while the
content of the resumed execution context is loaded (into CPU registers etc.).

\paragraph*{Parent context}
The pointer to its \emph{parent} execution context allows to traverse the chain
of ancestor context's, e.g. the execution context which has resumed (\ectxop
called) the running context.

\paragraph*{Active context}
Static member function \ectxcurrent returns a \ectx pointing to the current
capture record (e.g. execution context). The current active capture record is
stored in an internal, thread local pointer.

\paragraph*{Toplevel capture records}
At entering \main as well as the \emph{thread-function} of a thread, a execution
context (capture record) is created and stored in the internally.
\ectxcurrent.

\uabschnitt{Suspend-on-call}
\ectx is designed to suspend on call of \ectxop. The \emph{prolog} of \ectxop
captures (preserves) the active execution context and loads the data from the
capture record of the resumed context (e.g. \ectxop called on \emph{*this}) into
the CPU.\\
The previous running context becomes the parent of the resumed context and gets
suspended. Thus forming a parent-child relationship between suspended and
resumed context. The parent may vary between successive calls of \ectxop.

\paragraph*{Termination}
If the body of the toplevel context function reaches its end, the parent
execution context (pointer in the capture record) is resumed. That means that
in the parent context the function \ectxop returns. For this purpose the
\emph{epilog} of \ectxop loads the capture record (instruction pointer, stack
pointer etc.) of the parent context, so that it is resumed.

\uabschnitt{Exceptions}
A exception thrown inside the execution context is catched, the parent execution
context is resumed and the exception is re-thrown inside the parent context
(e.g. the exception is emitted by \ectxop).

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}[captures](params) {\color{blue}mutable} {\color{blue}resumable}(hint) {\color{blue}exceptions} attrs -> ret \{body\}} & (1)\\

    \midrule

    \cpp{execution_context(const execution_context& other)=default} & (2)\\

    \midrule

    \cpp{execution_context(execution_context&& other)=default} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] the constructor does not take a lambda as argument, instead the
              compiler evaluates the lambda-like syntax and constructs a \ectx
              directly
              \begin{description}
                  \item[captures]     list of captures
                  \item[params]       only empty parameter-list allowed
                  \item[mutable]      allows to modify parameters captured by copy
                  \item[resumable]    identify resumable context
                  \item[hint]         stack type hint:
                                      \begin{itemize}
                                          \item \cpp{fixedsize(x=default_stacksize)}:
                                              fixed size stack (\cpp{default_stacksize} is
                                              platform depended)
                                          \item \cpp{segmented(x=default_stacksize)}:
                                              stack grows on demand (\cpp{default_stacksize}
                                              is platform depended)
                                      \end{itemize}
                  \item[exceptions]   only \cpp{noexcept} allowed; emitted exceptions
                                      trigger \cpp{std::terminate()}
                  \item[attrs]        attributes for \cpp{operator()}
                  \item[ret]          only \cpp{void} allowed; resumable lambda returns nothing
                                      (use of capture list instead)
                  \item[body]         function body\\
              \end{description}
    \item[2)] copies \ectx, e.g. underlying control block is shared
    \item[3)] moves underlying control block to new \ectx
\end{description}

{\bfseries Notes}
\newline
If an instance of \ectx is copied, both instances share the same underlying
control block. Resuming one instance modifies the control block of the other
\ectx too.

\subparagraph*{(destructor)}
destroys a execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal control block, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context& operator=(execution_context&& other)} & (1)\\

    \midrule

    \cpp{execution_context& operator=(const execution_context& other)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copies the state of \emph{other} to \emph{*this}, state (control block)
              is shared
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}execution\_context\& {\color{blue}operator}()()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] resumes the execution context\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] re-throws the exception of the resumed context in the parent context\\
\end{description}

{\bfseries Notes}
\newline
A exception thrown inside execution context is catched, the parent execution
context is resumed and the exception is re-throw in the parent context (out of
\ectxop).\\
If the toplevel context function terminates (reaches end), the parent context is
resumed (return of\\
\ectxop in the parent execution context).\\
The behaviour is undefined if \cpp{operator()} is called while \cpp{current()}
returns \emph{*this} (e.g. resuming an already running context).

\subparagraph*{explicit bool operator}
test if context has not reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}explicit} {\color{blue}bool} {\color{blue}operator}() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is not terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator!}
test if context has reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}bool} {\color{blue}operator}!() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution_context current()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct a instance of \ectx pointing to the capture record of
              the current, active execution context\\
\end{description}

{\bfseries Notes}
\newline
The current active execution context is thread-specific, e.g. for each thread
(including \main) a execution context is created at start-up.
