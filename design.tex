\abschnitt{Design}
Class \ectx is derived from the work on boost.context\cite{bcontext} - it
provides a small, basic API, suitable to implement high-level APIs for stackful
coroutines (as proposed in N3985\cite{N3985},
boost.coroutine2\cite{bcoroutine2}) and user-mode threads (executing tasks in a
cooperative multitasking environment, boost.fiber\cite{bfiber}).\\

\uabschnitt{Class \ectx}
\ectx provides only one operations to switch the execution context
\ectxop (symmetric operation) - that implies that \ectx needs to specify
explictly to which other context the execution control has to be transferred to.
Transfering data from and to the context requires the use of lambdas, especially
lambda captures.

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context(StackAlloc salloc,Fn&& fn,Args&&... args);} & (1)\\

    \midrule

    \cpp{execution_context(execution_context const& other)=default;} & (2)\\

    \midrule

    \cpp{execution_context(execution_context&& other)=default;} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \ectx
              \begin{itemize}
                  \item \textit{salloc} allocates/deallocates stack
                  \item \textit{fn} function executed in the new context
                  \item \textit{args} parameter pack passed to \textit{fn}
              \end{itemize}
    \item[2)] copies \ectx, e.g. underlying control block is shared
    \item[3)] moves underlying cotnrol block to new \ectx
\end{description}

{\bf Notes}
\newline
If an instance of \ectx is copied, both instances share the same underlying
control block (CPU registers, stack). Resuming one instance modifies the
control block (internal state) of the other \ectx too.\\
If this is behaviour is not permitted, the stack has to be copied. That requires
identification and modification of local variables pointing to address of the
stack.\\

\subparagraph*{(destructor)}
destroys a execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution_context();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If that \ectx is associated with a context of execution
              and holds the last reference to the internal control block,
              then the context of execution is destroyed too. Specifically,
              its stack is unwound.\\
\end{description}

\subparagraph*{operator=}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context_type & operator=(execution_context_type&& other);} & (1)\\

    \midrule

    \cpp{execution_context_type & operator=(const execution_context_type& other);} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \textit{other} to *this using move semantics
    \item[2)] copies the state of \textit{other} to *this, state (control block) is shared
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object\\
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void operator()();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] resumes the execution context\\
\end{description}

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution_context current();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct a instance of \ectx associated with the current execution context\\
\end{description}

\uabschnitt{Stackful resumable lambda}
Based on teh implementation expiriance with \cpp{executin_context} the author
encountered that \cpp{execution_context} is always used together with lambdas
(executed inside the new execution context). Especially the lambda captures are
suitable to transport data between different execution context's.\\
This pattern could be an indication that \ectx + lambdas should be trnasformt
in a syntax for resumable lambdas, smilar as described in N4244\cite{N4244}.\\
The differences to N4244 are the absence of keyword \yield because of the
symmetric context switching (== only one operation transfers the control of
execution), e.g. the target of a context switch must be explicitly specified.\\
Stackful resumabel lambdas required keyword \resumable together with an hint
(attribute) about the type and size of the stack -
\cpp{auto l=[]()resumable(fixedsize(1024)){...}}.
Hint types are \cpp{fixedsize()} and \cpp{segmented()} - \cpp{fixedsize(x)}
tells the compiler to allocate an new (or re-use a cached) stack with the given
size \textit{x} bytes. With \cpp{segmented(y)} an linked stack that grows on demand
with an initial size of \textit{y} bytes is used.\\
If the compiler is able to analyse the function body (including all
sub-routines) the compiler might ignore the hint and allocated an approbriate
sized stack.\\
\newline
The example of an recursive descent parser would look like
\cppf{lparser.cpp}

\uabschnitt{Combined syntax?}
The author assumes, that a syntax, combining stackless and stackful resumable
lambdas, would be possible.\\
Stackful resumable lambdas are identified by the additional stack hint, e.g.
\cpp{[capture-list] (params) mutable(optional) exception attribute -> void \{body\}}

\begin{tabular}{ l l }
    \midrule

    \cpp{[capture-list] (params) mutable resumable(hint) exceptions attribute -> ret \{body\}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Full declaration
\end{description}

{\bf Parameters}
\begin{description}
    \item[mutable]      allows to modify parameters captured by copy
    \item[resumable]    indentify resumable operation
    \item[hint]         stack type hint:
                        \begin{itemize}
                            \item <no hint specified>: create stackless resumable lambda
                            \item \textit{fixedsize(x)}: create stackful resumable lambda; fixed size stack
                            \item \textit{segmented(x)}: create stackful resumable lambda; stack grows on demand
                        \end{itemize}
    \item[exceptions]   only \textit{noexcept} allowed; no exception is permitted to leave the body
    \item[attribute]    attributes for \cpp{operator()}
    \item[capture-list] list of captures
    \item[params]       only empty parameter-list allowed
    \item[ret]          only \textit{void} allowed; resumabel lambda returns nothing
    \item[body]         function body\\
\end{description}

Because the function \main can be interpreted as an execution context too
(e.g. control block with CPU registers, stack, local variables) the API needs
the possibily to access the context currently executed. The author suggestes an
free-standing function similar to \ectxcurrent.
