\abschnitt{Design}
The design of \ectx is based on N4397\cite{N4397} with one modification - the
\emph{lambda-like expression} does not have the \emph{hint} attribute.\\
Instead the compiler desides if one activation record is sufficient
(\emph{stackless}) or a side stack is required (\emph{stackful}). The compiler 
makes the decision based on the analysis of the toplevel context function.
If the compiler can prove that context switches are only done at the toplevel
function and not from nested call stack (from subroutines), than a
\emph{stackless} execution context is created. Otherwise the compiler constructs
a \ectx with a non-contiguous, linked side stack. The initial default stacksize
depends on the platform.

\uabschnitt{First-class object}
As a first-class object, the execution context can be stored in a variable or
container.

\uabschnitt{Capture record}
Each instance of \ectx owns a toplevel activation record, the capture record.
The capture record is a special activation record that stores additional data
like stack pointer, instruction pointer and a link to its parent execution
context. That means that during an execution context switch, the execution state
of the running context is captured and stored in the capture record while the
content of the resumed execution context is loaded (into CPU registers etc.).

\paragraph*{Parent context}
The pointer to its \emph{parent} execution context allows traversing the chain
of ancestor contexts, i.e. the execution context which has resumed (called \ectxop
on) the running context.

\paragraph*{Active context}
Static member function \ectxcurrent returns a\\
\ectx pointing to the current capture record (execution context). The
current active capture record is stored in an internal, thread local pointer.

\paragraph*{Toplevel capture records}
On entering \main as well as the \emph{thread-function} of a thread, an execution
context (capture record) is created and stored in the internal thread-local
pointer underlying\\\ectxcurrent.

\paragraph*{Termination}
If the body of the toplevel context function reaches its end, the parent
execution context (pointer in the capture record) is resumed. That means that
in the parent context the function\\
\ectxop returns. For this purpose the \emph{epilogue} loads the capture record
(instruction pointer, stack pointer etc.) of the parent context, so that it is
resumed.

\uabschnitt{Exceptions}
An exception thrown inside the execution context is caught, the parent execution
context is resumed and the exception is re-thrown inside the parent context:
the exception is emitted by\\\ectxop.
\newpage

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}[captures](params) {\color{blue}mutable} {\color{blue}resumable} attrs -> ret \{body\}} & (1)\\

    \midrule

    \cpp{execution_context(const execution_context& other)=default} & (2)\\

    \midrule

    \cpp{execution_context(execution_context&& other)=default} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] the constructor does not take a lambda as argument, instead the
              compiler evaluates the lambda-like syntax and constructs a \ectx
              directly
              \begin{description}
                  \item[captures]     list of captures
                  \item[params]       only empty parameter-list allowed
                  \item[mutable]      parameters captured by copy can be modified by \emph{body}
                  \item[resumable]    identify resumable context
                  \item[attrs]        attributes for \cpp{operator()}
                  \item[ret]          only \cpp{void} allowed
                                      (use capture list instead)
                  \item[body]         function body\\
              \end{description}
    \item[2)] copies \ectx, e.g. underlying capture record is shared
    \item[3)] moves underlying capture record to new \ectx
\end{description}

\subparagraph*{(destructor)}
destroys a execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys an \ectx. If associated with a context of execution and
              holds the last reference to the internal capture record, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context& operator=(execution_context&& other)} & (1)\\

    \midrule

    \cpp{execution_context& operator=(const execution_context& other)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copies the state of \emph{other} to \emph{*this}, state (capture record)
              is shared
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}execution\_context\& {\color{blue}operator}()()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes the execution context\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] re-throws the exception of the resumed context in the parent context\\
\end{description}

{\bfseries Notes}
\newline
The \emph{prologue} preserves the execution context of the calling context as well
as stack parts like \emph{parameter list} and \emph{return address}
\footnote{required only by some x86 ABIs}. Those data are restored by the
\emph{epilogue} if the calling context is resumed.
\newline
An exception thrown inside execution context is caught, the parent execution
context is resumed and the exception is re-thrown in the parent context (out of
\ectxop).\\
If the toplevel context function terminates (reaches end), the parent context is
resumed (return of\\
\ectxop in the parent execution context).\\
The behaviour is undefined if \cpp{operator()} is called while \cpp{current()}
returns \emph{*this} (e.g. resuming an already running context).

\subparagraph*{explicit bool operator}
test if context has not reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}explicit} {\color{blue}bool} {\color{blue}operator}() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is not terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator!}
test if context has reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}bool} {\color{blue}operator}!() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution_context current()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct a instance of \ectx pointing to the capture record of
              the current, active execution context\\
\end{description}

{\bfseries Notes}
\newline
The current active execution context is thread-specific: for each thread
(including \main) an execution context is effectively created at start-up.
