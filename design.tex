\abschnitt{Design Decisions}
This section describes two designs - one with unidirectional and an alternative
design with bidirectionial transfer of data.

\subsubsection*{Proposed Design}
\boostcoroutine provides a interface (BOOST\_COROUTINES\_UNIDIRECT) with
unidirectional flow of data between \corofunction and caller.\\
The design suggests two unidirectional coroutine types: \pushcoro and
\pullcoro.\\
The advantage regarding to a bidirectional coroutine is the simplified template
argument and a distinct direction of data flow.\\
Instead of an signature \pullcoro and \pushcoro use only one template argument
describing the type which is exchanged between the context switches.
\cppf{fibonacci.cpp}

\paragraph*{push\_coroutine:}
With \pushcoro a parameter is transferred to the other execution context (for
instance to \corofunction) == pushed-to.\\
The class has only one template parameter defining the parameter type pushed to
\corofunction.\\
\newline
The interface does not contain a \cpp{get()}-function, e.g. you can not retrieve
values from another execution context with this kind of coroutine.

\paragraph*{pull\_coroutine:}
With \pullcoro a parameter is retrieved from the other execution context (for
instance from \corofunction) == pulled-from.\\
The class has only one template parameter defining the parameter type pulled
from \corofunction.\\
\newline
This kind of coroutine provides only \pullcoroop which does only switch the
context and transfers no data.

\paragraph*{stack-full:}
Each instance of a coroutine has its own stack.\\
\newline
In contrast to stack-less coroutines allow stack-full coroutines to invoke the
suspend operation out of arbitrary sub-stackframes enabling \escreops.

\paragraph*{move-only:}
A coroutine is moveable-only.\\
\newline
If it would be copyable then its stack with all the objects allocated on it
are copied too. This could force undefined behaviour if some of this objects are
RAII-classes (manage a resource via RAII pattern). If one of the copies
terminates (unwinds its stack) the RAII-classes releases their managed resources
at destruction.

\paragraph*{clean-up:}
On destruction the associated stack will be unwind.\\
\newline
The implementer is free to deallocate the stack or cache it for future usage
(for coroutines created later).

\paragraph*{segmented stack:}
\pushcoro and \pullcoro must support segmented stacks (growing on demand).\\
\newline
It is not always possible to estimated the required stack size - in most cases
too much memory is allocated (wast of virtual address-space).\\
\newline
At construction a coroutine starts with a default (minimal) stack size. This
minimal stack size is the maximum of page size and the canonical size for signal
stack (macro SIGSTKSZ on POSIX).\\
\newline
At this time of writing only GCC (4.7)\cite{gccsplit} is known to support
segmented stacks. With version 1.54 \boostcoroutine provides support for
segmented stacks.\\
\newline
The destructor deallocates the associated stack. The implementer is free to
deallocated the stack or to cache it for later usage.

\paragraph*{context switch:}
A coroutine stores and restores registers according to the underlying ABI on
each context switch.\\
\newline
This includes also the floating point environment as required by the ABI. The
implementer can omit preserving the floating point env if he can predict that
it's safe.\\
\newline
On POSIX systems coroutine must not preserve signal masks for performance
reasons.\\
\newline
A context switch is done via \pushcoroop and \pullcoroop.

\paragraph*{coroutine-function:}
The \corofunction returns \cpp{void} and takes its counterpart-coroutine as
argument, so that using the coroutine passed as argument to \corofunction is the
only way to transfer data and execution control back to the caller.\\
Both coroutine types take the same template argument.\\
For \pullcoro the \corofunction is entered at \pullcoro construction.\\
For \pushcoro the \corofunction is not entered at \pushcoro construction but
entered by the first invocation of \pushcoroop.\\
After execution control is returned from \corofunction the state of the
coroutine can be checked via \pullcorobool returning true if the coroutine is
still valid (\corofunction has not terminated) and data is available.
\cppf{corofn_startup.cpp}
Otherwise, detecting the completeness of a coroutine would require an extra context
switch (return from last \pullcoroop, \pushcoroop and calling return in the \corofunction).\\
This makes the implementation for iterators very hard and \cpp{std::distance}
would return 4 instead of 3 in the example above.

\paragraph*{passing parameters:}
Parameters are passed from the main-context to the \corofunction via
\pushcoroop.\\
\newline
\pushcoroop accepts an argument as defined in the template argument in
\pushcoro.
A context switch is executed and the passed parameter will be accessible in
the \corofunction.

\paragraph*{accessing parameters:}
Parameters returned from the \corofunction can be accessed with
\pullcoroget.\\
\newline
Splitting-up the access of parameters from context switch function enables to
check if \pullcoro is valid after return from \pullcoroop, e.g. \pullcoro has
values and \corofunction has not terminated.
\cppf{access_params.cpp}

\paragraph*{returning parameters:}
Results can be returned by a \corofunction via \pushcoroop.\\
\cppf{return_params.cpp}

\paragraph*{exceptions:}
An exception thrown inside \corofunction will re-thrown by \pullcoro
constructor, \pullcoroop or \pushcoroop.

\paragraph*{input iterator:}
\pullcoro provide input iterators.
\cppf{output_iterator.cpp}

\paragraph*{output iterator:}
\pushcoro provide output iterators.


\subsubsection*{Alternative Design}
An alternative to unidirectional data exchange between coroutine and its caller
would be a interface (BOOST\_COROUTINES\_BIDIRECT) with bidirectional flow of
data. The template argument of \coro is a signature defining passed argument and
return types.

\paragraph*{coroutine-function:}
The \corofunction returns \cpp{void} and takes its counterpart-coroutine
(inverted signature) as argument (used to switch back to caller).\\
The \corofunction is entered upon construction of \coro not upon the first call of
\coroop.\\
After execution control is returned from \corofunction the state of the
coroutine can be checked via \corobool.\\
\corobool returns true if the coroutine is still valid (\corofunction has not
terminated) and data is available.\\
The coroutine passed as argument to the \corofunction has an inverted
signature, e.g. return types become arguments and vice versa.
\cppf{alternative_corofn_startup.cpp}

\coro, started from the main-context, has a signature of \cpp{int(void)} - it
returns an integer from \corofunction.\\
The \coro argument of \corofunction \cpp{f} has therefore a signature of
\cpp{void(int)} - it transfers an integer to caller.

\paragraph*{passing parameters:}
Parameters are passed to the \corofunction via \coroop.\\
\newline
\coroop accepts arguments as defined in the template arguments in \coro. A
context switch is executed and the passed parameters will be accessible in in
the \corofunction.

\paragraph*{accessing parameters:}
Parameters returned from the \corofunction can be accessed with \coroget.\\
\newline
In contrast to single argument in coroutine signature multiple arguments are
returned via \tuple from \coroget.\\
Splitting-up the access of parameters from context switch function enables to
check if \coro is valid after return from \coroop, e.g. \coro has values and
\corofunction has not terminated.
\cppf{alternative_access_params.cpp}

\paragraph*{returning parameters:}
Results can be returned by a \corofunction via \coroop.\\
\newline
Like passing parameters to the \corofunction the \corofunction can return
results to the caller.\\
This is done by calling the \coroop of the \coro given as first argument to
\corofunction.
\cppf{alternative_return_params.cpp}

\paragraph*{input iterator:}
\cpp{std::coroutine<T(void)>} provide input iterators.
\cppf{alternative_output_iterator.cpp}

\paragraph*{output iterator:}
\cpp{std::coroutine<void(T)>} provide output iterators.


\subsubsection*{Other libraries}
\paragraph*{boost.coroutine from 'Google Summer of Code 2006':}
\boostcoroutine is a follow-up on \boostcorosum which is unfinished and
not part of the official boost release (development of this library was
stopped).\\
During the boost review process interface of \boostcoroutine was changed and
differ in some parts to \boostcorosum.

\paragraph*{Mordor:}
Mordor\cite{mordor} is another C++ library implementing cooperative multitasking
in order to achieve high I/O performance. The difference to this design is that
this proposal focus on enhanced control flow while Mordor\cite{mordor} abstracts
on the level of tasking (providing a cooperatively scheduled fiber engine).

\paragraph*{AT\&T Task Library:}
Another design of a task library was published by AT\&T\cite{atnt1989} describing
a tasking system with non-preemptive scheduling.\\
\coro does not provide scheduling logic but could be used as the basic mechanism
for such kind of tasking abstractions.

\paragraph*{C++ proposal: resumable functions (N3328\cite{n3328}):}
This proposal is a library superset of N3328 - the \resumfn can be implemented
on top of \coro. The proposed coroutine does not require memory allocation for
the future on a switch and does not require language changes (no keywords like
\textit{resumable} and \textit{await}).\\
As described in section 3.2.5 'Function Prolog' - the body of a \resumfn is
transformed in a switch statement. This is similar to the stackless coroutines
of Python an C\#.\\
A proof-of-concept how \await could be build upon \boostcoroutine was already
implemented in \awaitemu.\\
\newline
Without stackfulness and first-class semantic some useful execution control
flows cannot be supported (for instance cooperative multitasking,
checkpointing) and the 'same fringe' example would not be easily implementable.

\subsubsection*{Further Additional Features}
It might be possible to extend the design for \checkpointing - the execution of
a coroutine can be rolled back to a certain point (the \checkpoint) in the code.
\cppf{checkpoint.cpp}
In the example above the text 'ABC' will be printed again if the coroutine
is resumed after the rollback.\\
\newline
With the support of \checkpointing some kind of copying of coroutines might be
possible too.
