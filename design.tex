\abschnitt{Design}
Class \ectx provides a {\bfseries small, basic API} on which to build {\bfseries
higher-level APIs} such as stackful coroutines (N3985\cite{N3985}) and user-mode
threads (such as Boost.Fiber\cite{bfiber}).


\uabschnitt{Suspend-by-call}
\ectxop preserves the CPU register set\footnote{defined by ABI's calling
convention}: the content of those registers is pushed at the end of the stack
of the current context (at the current stack-pointer). Then \op restores the
stack-pointer register stored in \cpp{*this} and pops the CPU register set
from the newly-restored stack.
Because the context state is preserved on the context's stack, a \ectx
instance need only store the stack-pointer register.


\uabschnitt{Call semantics}
When \ectxop is called, a new instance of \ectx is synthesized representing
the current state of the running context (e.g. the stack-pointer). This new
instance is passed to the resumed context. On initial entry, it is passed as
the first argument to the top-level function. On every subsequent resumption,
it is returned by the suspended \op call.

On completion of a successful context switch, the
\ectx instance on which \op was called is invalidated. The data member from
which the stack pointer was just restored is set to \cpp{nullptr}.

At most one instance of \ectx can represent a given execution context. The
currently-running execution context is not represented by \emph{any} \ectx
instance. Only when \op is called on some \emph{other} \ectx instance is the
state of the running execution context captured in a synthesized \ectx
instance.

As mentioned in the section below on stack
destruction, \cpp{\~execution\_context<>()} on a suspended (not terminated)
instance destroys the stack managed by that instance. Thus, the stack must be
managed by only one \ectx instance.\footnote{An earlier design used reference
counting, but that subverts the intended role of this facility as an extremely
fast substrate for higher-level libraries.}

Because of the symmetric context switching (only one operation transfers
control), the target execution context must be explicitly specified.

\uabschnitt{std::execution\_context<void>}
With \cpp{execution\_context<void>} no data will be transferred, only the
context switch is executed.
\cppf{passing_void}
\cpp{ctx1()} resumes \cpp{ctx1}, that is, control enters the lambda passed to
the constructor of \cpp{ctx1}. Argument \cpp{ctx2} represents the previous
context: the context that was suspended by the call to \cpp{ctx1()}. When the
lambda returns \cpp{ctx2}, context \cpp{ctx1} will be terminated while the
context represented by \cpp{ctx2} is resumed, hence control returns
from \cpp{ctx1()}.\\

\uabschnitt{Passing data}
When you construct a \ectx with template arguments other than \cpp{void}, the
function or lambda that initializes that instance must accept parameters\\
\cpp{(std::execution\_context<args...>, args...)}, where \cpp{args...} here
represents any list of arguments other than \cpp{void}.

The initial \ectx argument is synthesized by \op. All other arguments must be
passed explicitly to \op.

The first call to \op with those arguments populates the parameter list for
the newly-entered function or lambda.

That function or lambda switches context back to the original context by
calling the passed\\
\ectxop, passing appropriate arguments.

The \emph{original} context's call to \op returns
a \cpp{std::tuple<std::execution\_context<args...>, args...>}. The
returned \ectx is a synthesized instance representing the context that just
suspended. The rest of the \cpp{args...} are as passed by that context to \op.

So, for instance:
\cppf{passing_single}
The \cpp{ctx1(i)} call at (a) enters the lambda in context \cpp{ctx1} with
argument \cpp{j=1}, as shown by the output at (b). The
expression \cpp{ctx2(j+1)} at (c) resumes the original context (represented
within the lambda by \cpp{ctx2}) and transfers back an integer of \cpp{j+1}.
On return from \cpp{ctx1(i)}, the assignment at (d) sets \cpp{i} to \cpp{j+1},
or 2.

The assignment at (d) illustrates a recommended idiom: since the call to \op
at (a) has invalidated \cpp{ctx1}, it should be replaced by the
newly-synthesized \ectx instance returned by \op.

To continue the example:
\cppf{passing_single_continued}
The call to \cpp{ctx1(i)} at (e) (the \emph{updated} \cpp{ctx1}) resumes
the \cpp{ctx1} lambda, returning from the \cpp{ctx2()} call at (c) and
executing the assignment at (f). Here, too, we replace the \ectx
instance \cpp{ctx2} invalidated by the \op call at (c) with the new instance
returned by that same \op call. Moreover, we replace \cpp{j} with the value
passed by the call at (e).

Finally the lambda returns (the updated) \cpp{ctx2} at (g), terminating its
context.

Since the updated \cpp{ctx2} represents the context suspended by the call at
(e), control returns to the assignment at (h). Once again we replace the
invalidated \cpp{ctx1} with the one returned by \op.

However, since context \cpp{ctx1} has now terminated, the updated \cpp{ctx1}
is \emph{not-a-context}. Its \cpp{operator bool()} returns \cpp{false};
its \cpp{operator\!()} returns \cpp{true}.

This is important, since in that case the values of any remaining fields of
the returned \cpp{std::tuple} are indeterminate.

It may seem tricky to keep track of which \ectx instance is currently
``live,'' representing the state of the suspended context. Please bear in
mind that this facility is intended as a high-performance foundation for
higher-level libraries. It is not intended to be directly consumed by
applications.\\
\newline
We can extend the example to multiple arguments.
\cppf{passing_multiple}
\op accepts the parameters specified by \ectx's template parameters. It
returns a \cpp{std::tuple} of that \ectx specialization prepended to those
types.


\uabschnitt{Top-level thread functions}
\main as well as the \emph{entry-function} of a thread can be represented by an
execution context. That \ectx instance is synthesized when the running context
suspends, and is passed into the newly-resumed context.


\uabschnitt{Termination}
The toplevel context function has to return the context which is resumed after
the current context has terminated.


\uabschnitt{Exceptions}
If an uncaught exception escapes from the toplevel context function,
\cpp{std::terminate} is called.


\uabschnitt{Executing function on top of a context}
Sometimes it is useful to execute a new function (for instance trigger unwinding
the stack) on top of a resumed context. For this purpose
\cpp{execution\_context::operator()} with first argument \cpp{invoke\_ontop\_arg}
has to be used. The function passed as argument must return a tuple of
\cpp{execution\_context} and arguments.
\cppf{ontop}
The expression \cpp{ctx(invoke\_ontop\_arg,f2,data+1)} executes \cpp{f2()} on
top of context \cpp{ctx}, e.g. an additional stack frame is allocated on top of
the context stack (in front of \cpp{f1()}). \cpp{f2()} returns argument -1 that
will returned by the second invocation of \cpp{ctx(data+1)} in \cpp{f1()}.


\uabschnitt{Stack destruction}
On construction of \cpp{execution\_context} a stack is allocated. If the
context-function returns the stack will be destructed. If the context-function
has not yet returned and the destructor of an valid \cpp{execution\_context}
instance (e.g. \cpp{execution\_context::operator bool()} returns true) is
called, the stack will be destructed too.


\uabschnitt{API}
declaration of class \ectx
\cppf{ec}
\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename StackAlloc, typename Fn, typename ... Args>}\\
    \cpp{execution\_context(std::allocator\_arg\_t, StackAlloc salloc,}\\
    \cpp{                   Fn&& fn, Args&& ... args)} & (2)\\

    \midrule

    \cpp{template<typename Fn, typename ... Args>}\\
    \cpp{explicit execution\_context(Fn&& fn, Args&& ... args)} & (3)\\

    \midrule

    \cpp{execution\_context(execution\_context&& other)} & (4)\\

    \midrule

    \cpp{execution\_context(const execution\_context& other)=delete} & (5)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor represents \emph{not-a-context}
    \item[2)] this constructor takes (e.g.) a lambda as argument, stack is
              constructed using \emph{salloc}
    \item[3)] takes (e.g.) lambda as argument,
              stack is constructed using either \cpp{fixedsize}
              or \cpp{segmented}. An implementation may infer which of these
              best suits the code in \cpp{fn}. If it cannot
              infer, \cpp{fixedsize} will be used.
    \item[4)] moves underlying capture record to new \ectx
    \item[5)] copy constructor deleted
\end{description}

{\bfseries Notes}
\newline
When an \ectx is constructed using either of the constructors accepting
\cpp{fn}, control is \emph{not} immediately passed to \cpp{fn}. Resuming
(entering) \cpp{fn} is performed by calling \cpp{operator()()} on the new
\ectx instance.\\

\subparagraph*{(destructor)}
destroys an execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution\_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal capture record, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the context object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution\_context& operator=(execution\_context&& other)} & (1)\\

    \midrule

    \cpp{execution\_context& operator=(const execution\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
resume context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{std::tuple<execution\_context, Args ...> operator()(Args ... args)} & (1)\\

    \midrule

    \cpp{execution\_context<void> operator()()} & (2) \\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{std::tuple<execution\_context, Args ...>}\\
    \cpp{operator()(invoke\_ontop\_arg\_t, Fn&& fn, Args ... args)} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{execution\_context<void>}\\
    \cpp{operator()(invoke\_ontop\_arg\_t, Fn&& fn)} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes the execution context
    \item[2)] specialization of (1) for \cpp{execution\_context<void>}
    \item[3)] suspends the active context, resumes the execution context but
        executes \cpp{fn(args ...)} in the resumed context (e.g. on top of the
        last stack frame)
    \item[4)] specialization of (3) for \cpp{execution\_context<void>}
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[... args] passed to current context  returned by the most recent call
                    to \cpp{execution\_context::operator()}\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[tuple]    of \cpp{execution\_context} and returned arguments passed to
                    the most recent call to\\ \cpp{execution\_context::operator()},
                    if any and a \cpp{execution\_context} representing the
                    context that has been suspended\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes toplevel \cpp{fn}\\
\end{description}

{\bfseries Notes}
\newline
The \emph{prologue} preserves the execution context of the calling context as
well as stack parts like \emph{parameter list} and \emph{return
address}.\footnote{required only by some x86 ABIs} Those data are restored by
the \emph{epilogue} if the calling context is resumed.
\newline
A suspended \cpp{execution\_context} can be destroyed. Its resources will be
cleaned up at that time.
\newline
The returned \cpp{execution\_context} indicates if the suspended context has
terminated (return from context-function) via \cpp{bool operator()}.
If the returned \cpp{execution\_context} has terminated no data are transferred
in the returned tuple.


\subparagraph*{operator bool}
test context if valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{explicit operator bool() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} refers to an valid \ectx,
              \cpp{false}\xspace otherwise
\end{description}

\subparagraph*{operator!}
test context if not valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator\!() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} refers not to an valid \ectx,
              \cpp{false}\xspace otherwise
\end{description}


\uabschnitt{Stack allocators}
are described in P0099R0\cite{P0099R0}.
