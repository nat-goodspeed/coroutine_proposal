\abschnitt{Design}
Class \ectx is derived from Boost.Context\cite{bcontext}. It
provides a {\bfseries small, basic API} on which to build {\bfseries
higher-level APIs} such as stackful coroutines (N3985\cite{N3985}, working
implementation Boost.Coroutine2\cite{bcoroutine2}) and user-mode threads
(cooperative multitasking environment, working
implementation Boost.Fiber\cite{bfiber}).

In effect, \cpp{execution\_context} is a copyable handle to an underlying,
noncopyable \emph{capture record}.

\cpp{execution\_context::operator()} preserves the CPU register
set\footnote{defined by ABI's calling convention} + stack pointer: the content of
those registers is stored in the capture record associated with
\cpp{execution\_context::current()}. Then \cpp{operator()} loads the CPU register
set and stack pointer from the capture record associated with \cpp{*this}.

Finally, \cpp{execution\_context::operator()}
makes \cpp{*this} become \cpp{current()}.

\uabschnitt{Class \ectx}
\ectx is like a handle to a \emph{capture record} of an execution
context.
\cppf{N4397/rl1}
Because of the symmetric context switching (only one operation transfers
control), the target execution context must be explicitly specified.\\
Exchanging data between different execution contexts requires the use of lambda
captures.

\uabschnitt{First-class object}
As first-class object the execution context can be stored in a variable or
container.

\uabschnitt{Capture record}
Each instance of \ectx owns a toplevel activation record, the capture record.
The capture record is a special activation record that stores additional data
such as stack pointer and instruction pointer. That means that during a
context switch, the execution state of the running context is captured and
stored in the capture record while the content of the resumed execution
context is loaded (into CPU registers etc.).

\paragraph*{Active context}
The static member function \ectxcurrent returns a \ectx pointing to the
current capture record. The current active capture record is stored in an
internal, thread local pointer.

\paragraph*{Toplevel capture records}
On entering \main as well as the \emph{entry-function} of a thread, an execution
context (capture record) is created and stored in the internal pointer underlying
\ectxcurrent. (In practice, this could be lazily instantiated.)

\uabschnitt{Suspend-on-call}
\ectx is designed to suspend on call of \ectxop. The \emph{prologue} of \ectxop
captures (preserves) the active execution context and loads the data from the
capture record of the resumed context (\emph{*this}) into the CPU.

\paragraph*{Termination}
If the toplevel context function returns, \cpp{std::terminate} is called.

\uabschnitt{Exceptions}
If an uncaught exception escapes from the toplevel context
function, \cpp{std::terminate} is called.
\newpage

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template<typename CALLABLE> execution\_context(CALLABLE&&)} & (1)\\

    \midrule

    \cpp{execution\_context(const execution\_context& other)=default} & (2)\\

    \midrule

    \cpp{execution\_context(execution\_context&& other)=default} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] the constructor takes (e.g.) a lambda as argument
    \item[2)] copies \ectx, e.g. underlying capture record is shared
    \item[3)] moves underlying capture record to new \ectx
\end{description}

{\bfseries Notes}
\newline
If an instance of \ectx is copied, both instances share the same underlying
capture record.

\subparagraph*{(destructor)}
destroys an execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution\_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal capture record, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the context object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution\_context& operator=(execution\_context&& other)} & (1)\\

    \midrule

    \cpp{execution\_context& operator=(const execution\_context& other)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copies the state of \emph{other} to \emph{*this}, state (capture
              record) is shared
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}execution\_context\& {\color{blue}operator}()()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes the execution context\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate}\\
\end{description}

{\bfseries Notes}
\newline
The \emph{prologue} preserves the execution context of the calling context as well
as stack parts like \emph{parameter list} and \emph{return
address}.\footnote{required only by some x86 ABIs} Those data are restored by the
\emph{epilogue} if the calling context is resumed.
\newline
If an uncaught exception escapes from the execution
context, \cpp{std::terminate} is called.\\
If the toplevel context function returns (reaches end), \cpp{std::terminate}
is called.\\
The only way to leave an \cpp{execution\_context} without terminating the
calling process is to call
another \cpp{execution\_context}'s \cpp{operator()()}.\\
A suspended \cpp{execution\_context} can be destroyed. Its resources will be
cleaned up at that time.\\
The behaviour is undefined if \cpp{operator()} is called while \cpp{current()}
returns \emph{*this} (attempting to resume an already running context).

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution\_context current()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct an instance of \ectx pointing to the capture record of
              the current, active execution context\\
\end{description}

{\bfseries Notes}
\newline
The current active execution context is thread-specific, e.g. for each thread
(including \main) an execution context is created at start-up.
