\abschnitt{Design}
Class \ectx is derived from the work on boost.context\cite{bcontext} - it
provides a small, basic API, suitable to implement high-level APIs for stackful
coroutines (N3985\cite{N3985}, boost.coroutine2\cite{bcoroutine2}) and user-mode
threads (executing tasks in a cooperative multitasking environment,
boost.fiber\cite{bfiber}).

prolog of \cpp{execution_context::operator()} preserves CPU register set + stack pointer, e.g.
the content of those registers is stored in the associated control block. additionally the
control block of \cpp{*this} is resumed, e.g. the prolog loads the CPU register set and stack pointer
into the CPU.

epilog of \cpp{execution_context::operator()} restores the control block (registers + stack) of
the outer (resumed) context while the instruction in the epilog preserve the control block
of the suspended context.

\uabschnitt{Class \ectx}
Based on the implementation experience with \cpp{execution_context} in
boost.coroutine2\cite{bcoroutine2} and boost.fiber\cite{bfiber}, the author
noticed that \cpp{execution_context} is almost always used together with lambdas
(passed as argument to the constructor of \cpp{execution_context}). Especially
the lambda captures are suitable to transport data between different execution
context's (address of lvalue, reside on stack/heap).\\
Why not construct \ectx with an 'resumable lambda'-like syntax, instead of
passing a lambda as argument? \ectx is constructed like a lambda but actually it
is not of this type (because it is constructible from \ectxcurrent too).
\cppf{N4397/rl1.cpp}
The keyword \resumable together with an hint (attribute) about the type and size
of the side stack tells the compiler to generate a stackful execution context.\\
Because of the symmetric context switching (only one operation transfers the
control of execution) the target context must be explicitly specified.\\
Exchanging data between different execution context's requires the use of lambda
captures.

\uabschnitt{Start-up}
A main execution context is created at startup (entering function \main; same
applies for threads). The current (active) execution context can be accessed
through the static member function\\
\ectxcurrent.

\uabschnitt{Control block}
Each instance of \ectx owns one control block and each control block contains a
pointer to its \emph{parent} control block, e.g. the context who has resumed the
execution context (\ectxop called).\\
Static member function \ectxcurrent returns a \ectx pointing to the current
control block. The current active control block is stored in an internal thread
local pointer.

\uabschnitt{Termination}
If the body (lambda) of the coroutine reaches its end, the parent execution
context is resumed, e.g. function \ectxop returns in the parent context.

\uabschnitt{Exceptions}
A exception thrown inside the coroutine body (lambda) is catched, the parent
execution context is resumed and the exception is re-thrown inside the parent
context (e.g. the exception is re-throw in \ectxop).

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}[captures](params) {\color{blue}mutable} {\color{blue}resumable}(hint) {\color{blue}exceptions} attrs -> ret \{body\}} & (1)\\

    \midrule

    \cpp{execution_context(const execution_context& other)=default} & (2)\\

    \midrule

    \cpp{execution_context(execution_context&& other)=default} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] the constructor does not take a lambda as argument, instead the
              compiler evaluates the lambda-like syntax and constructs a \ectx
              directly
              \begin{description}
                  \item[captures]     list of captures
                  \item[params]       only empty parameter-list allowed
                  \item[mutable]      allows to modify parameters captured by copy
                  \item[resumable]    identify resumable context
                  \item[hint]         stack type hint:
                                      \begin{itemize}
                                          \item \cpp{fixedsize(x=default_stacksize)}:
                                              fixed size stack (\cpp{default_stacksize} is
                                              platform depended)
                                          \item \cpp{segmented(x=default_stacksize)}:
                                              stack grows on demand (\cpp{default_stacksize}
                                              is platform depended)
                                      \end{itemize}
                  \item[exceptions]   only \cpp{noexcept} allowed; emitted exceptions
                                      trigger \cpp{std::terminate()}
                  \item[attrs]        attributes for \cpp{operator()}
                  \item[ret]          only \cpp{void} allowed; resumable lambda returns nothing
                                      (use of capture list instead)
                  \item[body]         function body\\
              \end{description}
    \item[2)] copies \ectx, e.g. underlying control block is shared
    \item[3)] moves underlying control block to new \ectx
\end{description}

{\bfseries Notes}
\newline
If an instance of \ectx is copied, both instances share the same underlying
control block. Resuming one instance modifies the control block of the other
\ectx too.

\subparagraph*{(destructor)}
destroys a execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal control block, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context& operator=(execution_context&& other)} & (1)\\

    \midrule

    \cpp{execution_context& operator=(const execution_context& other)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copies the state of \emph{other} to \emph{*this}, state (control block)
              is shared
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

{\bfseries Notes}
\newline
If an instance of \ectx is copied, both instances share the same underlying
control block. Resuming one instance modifies the control block of the other
\ectx too.

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}void} {\color{blue}operator}()() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] resumes the execution context\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

{\bfseries Notes}
\newline
A exception thrown inside the coroutine body (lambda) is catched, the parent
execution context is resumed and the exception is re-throw in the parent
context (out of \ectxop).\\
If the coroutine function terminates (reaches end), the parent context is
resumed (return of\\
\ectxop in the parent execution context).\\
The behaviour is undefined if \cpp{operator()} is called while \cpp{current()}
returns \emph{*this} (e.g. resuming an already running context).

\subparagraph*{explict bool operator}
test if context has not reached end of coroutine function\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}explicit} {\color{blue}bool} {\color{blue}operator}() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is not terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator!}
test if context has reached end of coroutine function\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}bool} {\color{blue}operator}!() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution_context current()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct a instance of \ectx pointing to the control block of the
              current, active execution context\\
\end{description}

{\bfseries Notes}
\newline
The current active execution context is thread-specific, e.g. for each thread
(including \main) a execution context is created at start-up.
