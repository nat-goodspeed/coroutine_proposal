\abschnitt{Design Decisions}

\subsubsection*{Proposed Design}
The design suggests two coroutine types - \pushcoro and \pullcoro - providing a
unidirectional transfer of data.

\paragraph*{std::coroutine<>::pull\_type:}
transfers data from another execution context (== pulled-from).\\
The class has only one template parameter defining the transferred parameter
type.\\
The constructor of \pullcoro takes a function (\corofunction) accepting a
reference to a \pushcoro as argument. Instantiating a \pullcoro passes the
control of execution to \corofunction and a complementary \pushcoro is
synthesized by the runtime and passed as reference to \corofunction.\\
\newline
This kind of coroutine provides \pullcoroop. This method only switches
context; it transfers no data.\\
\newline
\pullcoro provides input iterators (\pullcoroiterator) and\\
\bgin/\ed are overloaded. The increment-operation switches the context and
transfers data.
\cppf{fibonacci.cpp}
In this example a \pullcoro is created in the main execution context taking a
lambda function (== \corofunction); calculates Fibonacci numbers in a simple
\textit{for}-loop).\\
The \corofunction is executed in a newly created execution context which is
managed by the instance of\\
\pullcoro.\\
A \pushcoro is automatically generated by the runtime and passed as reference
to the lambda function. This \pushcoro instance transfers each Fibonacci number
back to the main execution context by calling \pushcoroop and passing the
Fibonacci number as argument. The local state of \corofunction is preserved and
will be restored after transferring execution control back to \corofunction in
order to calculate the next Fibonacci number.\\
Because \pullcoro provides input iterators and \bgin/\ed are overloaded, a
\textit{range-based for}-loop can be used to iterate over the generated
Fibonacci numbers.

\paragraph*{std::coroutine<>::push\_type:}
transfers data to the other execution context (== pushed-to).\\
The class has only one template parameter defining the transferred parameter
type.\\
The constructor of \pushcoro takes a function (\corofunction) accepting a
reference to a \pullcoro as argument. In contrast to \pullcoro, instantiating a
\pushcoro does not pass the control of execution to \corofunction{ }- instead
the first call of \pushcoroop synthesizes a complementary \pullcoro and passes
it as reference to \corofunction.\\
\newline
The interface does not contain a \get-function: you can not retrieve
values from another execution context with this kind of coroutine.\\
\newline
\pushcoro provides output iterators (\pushcoroiterator) and\\
\bgin/\ed are overloaded. The increment-operation switches the context and
transfers data.
\cppf{layout.cpp}
In this example a \pushcoro is created in the main execution context taking a
lambda function (== \corofunction); taking strings and lay 'num' of them out to a
line.\\
The \corofunction is executed in a newly created execution context which is
managed by the instance of\\
\pushcoro.\\
The \pushcoro passes the strings from the main execution context to
\corofunction via calling \pushcoroop.\\
A \pullcoro is automatically generated by the runtime and passed as reference
to the lambda function. This \pullcoro instance access the strings passed
upstream from the main execution context by calling \pullcoroget and lays those
strings out to a line according the parameters \textit{num} and \textit{width}.\\
The local state of \corofunction is preserved and will be restored after
transferring execution control back to \corofunction.\\
Because \pushcoro provides output iterators and \bgin/\ed are overloaded, a
\cpp{std::copy}-algorithm can be used to iterate over the vector containing the
string an passing them to the coroutine.

\paragraph*{stackful:}
Each instance of a coroutine has its own stack.\\
\newline
In contrast to stackless coroutines, stackful coroutines allow invoking the
suspend operation out of arbitrary sub-stackframes, enabling \escreops.

\paragraph*{move-only:}
A coroutine is moveable-only.\\
\newline
If it were copyable, then its stack with all the objects allocated on it
would be copied too. That would force undefined behaviour if some of these objects
were RAII-classes (manage a resource via RAII pattern). When the first of the
coroutine copies terminates (unwinds its stack), the RAII class destructors will
release their managed resources. When the second copy terminates, the same
destructors will try to doubly-release the same resources, leading to undefined
behavior.

\paragraph*{clean-up:}
On coroutine destruction the associated stack will be unwound.\\
\newline
The implementer is free to deallocate the stack or cache it for future usage
(for coroutines created later).

\paragraph*{segmented stack:}
\pushcoro and \pullcoro must support segmented stacks (growing on demand).\\
\newline
It is not always possible to estimated the required stack size - in most cases
too much memory is allocated (waste of virtual address-space).\\
\newline
At construction a coroutine starts with a default (minimal) stack size. This
minimal stack size is the maximum of page size and the canonical size for signal
stack (macro SIGSTKSZ on POSIX).\\
\newline
At this time of writing only GCC (4.7)\cite{gccsplit} is known to support
segmented stacks. With version 1.54 \boostcoroutine provides support for
segmented stacks.\\
\newline
The destructor releases the associated stack. The implementer is free to
deallocate the stack or to cache it for later usage.

\paragraph*{context switch:}
A coroutine stores and restores registers according to the underlying ABI on
each context switch.\\
\newline
This includes also the floating point environment as required by the ABI. The
implementer can omit preserving the floating point env if he can predict that
it's safe.\\
\newline
On POSIX systems coroutine must not preserve signal masks for performance
reasons.\\
\newline
A context switch is done via \pushcoroop and\\
\pullcoroop.

\paragraph*{coroutine-function:}
The \corofunction returns \cpp{void} and takes its counterpart-coroutine as
argument, so that using the coroutine passed as argument to \corofunction is the
only way to transfer data and execution control back to the caller.\\
Both coroutine types take the same template argument.\\
For \pullcoro the \corofunction is entered at \pullcoro construction.\\
For \pushcoro the \corofunction is not entered at \pushcoro construction but
entered by the first invocation of \pushcoroop.\\
After execution control is returned from \corofunction the state of the
coroutine can be checked via\\
\pullcorobool returning true if the coroutine is still valid (\corofunction has
not terminated). Unless T is void, true also implies that a data value is
available.

\paragraph*{passing data from a pull-coroutine to main-context:}
In order to transfer data from a\\
\pullcoro to the main-context the framework synthezises a \pushcoro associated
with the \pullcoro instance in the main-context. The synthezised\\
\pushcoro is passed as argument to \corofunction.\\
In the \corofunction this \pushcoroop has to be called in order to transfer the
data value back to the main-context.\\
At main-context the \pullcorobool determines if the coroutine is still valid and
a data value is available or \corofunction has terminated (\pullcoro is invalid;
not data are available). Access to the transferred data value is given by
\pullcoroget.
\cppf{data_to_main.cpp}

\paragraph*{passing data from main-context to a push-coroutine:}
In order to transfer data to a\\
\pushcoro from the main.context the framework synthezises a \pullcoro associated
with the \pushcoro instance in the main-context. The synthesized\\
\pullcoro is passed as argument to \corofunction.\\
At main-context \pushcoroop has to be used in order to transfer a data value
from the main.context to the \corofunction.\\
In the \corofunction the \pullcorobool determines if the coroutine is still valid and
a data value is available.\\
Access to the transferred data value is given by \pullcoroget.
\cppf{data_from_main.cpp}

\paragraph*{accessing parameters:}
Parameters returned from or transferred to the \corofunction can be accessed
with \pullcoroget.\\
\newline
Splitting-up the access of parameters from context switch function enables to
check if \pullcoro is valid after return from \pullcoroop, e.g. \pullcoro has
values and \corofunction has not terminated.
\cppf{access_params.cpp}

\paragraph*{returning parameters:}
Results can be returned by a \corofunction via\\
\pushcoroop.\\
\cppf{return_params.cpp}

\paragraph*{exceptions:}
An exception thrown inside a \pullcoro's \corofunction before its first call to
\pushcoroop will be re-thrown by the \pullcoro constructor. After a \pullcoro's
\corofunction's first call to\\
\pushcoroop, any subsequent exception inside that
\corofunction will be re-thrown by \pullcoroop.\\
\pullcoroget does not throw.\\
\newline
An exception thrown inside a \pushcoro's \corofunction will be re-thrown by\\
\pushcoroop.


\subsubsection*{Other libraries}
\paragraph*{boost.coroutine from 'Google Summer of Code 2006':}
\boostcoroutine is a follow-up to \boostcorosum which is unfinished and
not part of the official boost release: development of this library was
stopped.\\
During the boost review process the interface of \boostcoroutine was changed; it
differs fairly significantly from \boostcorosum.

\paragraph*{Mordor:}
Mordor\cite{mordor} is another C++ library implementing cooperative multitasking
in order to achieve high I/O performance. The difference from this design is that
this proposal focuses on enhanced control flow, while Mordor\cite{mordor} abstracts
on the level of tasking: providing a cooperatively scheduled fiber engine.

\paragraph*{AT\&T Task Library:}
Another design of a task library was published by AT\&T\cite{atnt1989}
describing a tasking system with non-preemptive scheduling.\\
\pushcoro/\pullcoro does not provide scheduling logic but could be used as the
basic mechanism for such a tasking abstraction.

\paragraph*{C++ proposal: resumable functions (N3328\cite{n3328}):}
This proposal is a library superset of N3328: the \resumfn can be implemented
on top of coroutines. The proposed coroutine library does not require memory allocation
for the future on a context switch and does not require language changes (no keywords
like \textit{resumable} and \textit{await}).\\
As described in N3328 section 3.2.5 'Function Prolog' - the body of a \resumfn is
transformed into a switch statement. This is similar to the stackless coroutines
of Python and C\#.\\
A proof-of-concept how \await could be built upon \boostcoroutine has already been
implemented in \awaitemu.\\
\newline
Without stackfulness and first-class semantics, some useful execution control
flows cannot be supported (for instance cooperative multitasking,
checkpointing) and recursive problems such as the 'same fringe' example become
much more difficult.
