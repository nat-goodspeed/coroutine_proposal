\abschnitt{Design}
Class \ectx provides a {\bfseries low-level} and {\bfseries minimal API} on
which to build {\bfseries higher-level APIs} such as stackful coroutines
(N3985\cite{N3985}) and user-mode threads (such as Boost.Fiber\cite{bfiber}).


\uabschnitt{Suspend-by-call}
\ectxop preserves the CPU register set\footnote{defined by ABI's calling
convention}: the content of those registers is pushed at the end of the stack
of the current context (at the current stack-pointer). Then \op restores the
stack-pointer register stored in \cpp{*this} and pops the CPU register set
from the newly-restored stack.
Because the context state is preserved on the context's stack, a \ectx
instance need only store the stack-pointer register.


\uabschnitt{Call semantics}
When \ectxop is called, a new instance of \ectx is synthesized representing
the current state of the running context (e.g. the stack-pointer). This new
instance is passed to the resumed context. On initial entry, it is passed as
the first argument to the top-level function. On every subsequent resumption,
it is returned by the suspended \op call.

On completion of a successful context switch, the
\ectx instance on which \op was called is invalidated. The data member from
which the stack pointer was just restored is set to \cpp{nullptr}.

At most one instance of \ectx can represent a given execution context. The
currently-running execution context is not represented by \emph{any} \ectx
instance. Only when \op is called on some \emph{other} \ectx instance is the
state of the running execution context captured in a synthesized \ectx
instance.

As mentioned in the section below on stack
destruction, \cpp{\~execution\_context<>()} on a suspended (not terminated)
instance destroys the stack managed by that instance. Thus, the stack must be
managed by only one \ectx instance.\footnote{An earlier design used reference
counting, but that subverts the intended role of this facility as an extremely
fast substrate for higher-level libraries.}

Because of the symmetric context switching (only one operation transfers
control), the target execution context must be explicitly specified.

\uabschnitt{std::execution\_context<void>}
With \cpp{execution\_context<void>} no data will be transferred, only the
context switch is executed.
\cppf{passing_void}
\cpp{ctx1()} resumes \cpp{ctx1}, that is, control enters the lambda passed to
the constructor of \cpp{ctx1}. Argument \cpp{ctx2} represents the previous
context: the context that was suspended by the call to \cpp{ctx1()}. When the
lambda returns \cpp{ctx2}, context \cpp{ctx1} will be terminated while the
context represented by \cpp{ctx2} is resumed, hence control returns
from \cpp{ctx1()}.\\

\uabschnitt{Passing data}
When you construct a \ectx with template arguments other than \cpp{void}, the
function or lambda that initializes that instance must accept parameters\\
\cpp{(std::execution\_context<args...>, args...)}, where \cpp{args...} here
represents any list of arguments other than \cpp{void}.

The initial \ectx argument is synthesized by \op. All other arguments must be
passed explicitly to \op.

The first call to \op with those arguments populates the parameter list for
the newly-entered function or lambda.

That function or lambda switches context back to the original context by
calling the passed\\
\ectxop, passing appropriate arguments.

The \emph{original} context's call to \op returns
a \cpp{std::tuple<std::execution\_context<args...>, args...>}. The
returned \ectx is a synthesized instance representing the context that just
suspended. The rest of the \cpp{args...} are as passed by that context to \op.

So, for instance:
\cppf{passing_single}
The \cpp{ctx1(i)} call at (a) enters the lambda in context \cpp{ctx1} with
argument \cpp{j=1}, as shown by the output at (b). The
expression \cpp{ctx2(j+1)} at (c) resumes the original context (represented
within the lambda by \cpp{ctx2}) and transfers back an integer of \cpp{j+1}.
On return from \cpp{ctx1(i)}, the assignment at (d) sets \cpp{i} to \cpp{j+1},
or 2.

The assignment at (d) illustrates a recommended idiom: since the call to \op
at (a) has invalidated \cpp{ctx1}, it should be replaced by the
newly-synthesized \ectx instance returned by \op.

To continue the example:
\cppf{passing_single_continued}
The call to \cpp{ctx1(i)} at (e) (the \emph{updated} \cpp{ctx1}) resumes
the \cpp{ctx1} lambda, returning from the \cpp{ctx2()} call at (c) and
executing the assignment at (f). Here, too, we replace the \ectx
instance \cpp{ctx2} invalidated by the \op call at (c) with the new instance
returned by that same \op call. Moreover, we replace \cpp{j} with the value
passed by the call at (e).

Finally the lambda returns (the updated) \cpp{ctx2} at (g), terminating its
context.

Since the updated \cpp{ctx2} represents the context suspended by the call at
(e), control returns to the assignment at (h). Once again we replace the
invalidated \cpp{ctx1} with the one returned by \op.

However, since context \cpp{ctx1} has now terminated, the updated \cpp{ctx1}
is \emph{not-a-context}. Its \cpp{operator bool()} returns \cpp{false};
its \cpp{operator\!()} returns \cpp{true}.

This is important, since in that case the values of any remaining fields of
the returned \cpp{std::tuple} are indeterminate.

It may seem tricky to keep track of which \ectx instance is currently
``live,'' representing the state of the suspended context. Please bear in
mind that this facility is intended as a high-performance foundation for
higher-level libraries. It is not intended to be directly consumed by
applications.\\
\newline
We can extend the example to multiple arguments.
\cppf{passing_multiple}
\op accepts the parameters specified by \ectx's template parameters. It
returns a \cpp{std::tuple} of that \ectx specialization, prepended to those
types.


\uabschnitt{Top-level thread functions}
\main as well as the \emph{entry-function} of a thread can be represented by an
execution context. That \ectx instance is synthesized when the running context
suspends, and is passed into the newly-resumed context.


\uabschnitt{\ectx and std::thread}
The context represented by a \ectx instance is necessarily suspended. It is
valid to resume a \ectx instance on any thread -- \emph{except} that you must
not attempt to resume a \ectx instance representing \main, or
the \emph{entry-function} of some other \cpp{std::thread}, on any thread other
than its own.

\ectx provides a method to test for this.
If \cpp{std::execution\_context<>::any\_thread()} returns \cpp{false}, it is
only valid to resume that \ectx instance on the thread on which it was
initially launched.


\uabschnitt{Termination}
When you explicitly construct a particular \cpp{std::execution\_context<args...>}
specialization, passing its constructor a function or lambda, that callable
must accept that same\\
\cpp{std::execution\_context<args...>} specialization as
its first parameter. It must return that
same \cpp{std::execution\_context<args...>} specialization as well.

When that toplevel callable returns a \ectx instance, the running context is
voluntarily terminated. Control switches to the context indicated by the
returned \ectx instance.

If the toplevel callable returns the same \ectx instance it was originally
passed (or rather, the most recently updated instance returned from the
original instance's \op), control returns to the context that originally
resumed the running callable. However, the callable may return (switch to)
any reachable valid \ectx instance with the correct type signature.


\uabschnitt{Exceptions}
If an uncaught exception escapes from the toplevel context function,
\cpp{std::terminate} is called.


\uabschnitt{Invoke function on top of a context}
Sometimes it is useful to invoke a new function (for instance, to trigger
unwinding the stack) on top of a suspended context. For this purpose you may
pass to \ectxop:

\begin{itemize}
  \item the special argument \cpp{invoke\_ontop\_arg}
  \item the function to execute
  \item any additional arguments required by the \ectx specialization.
\end{itemize}

The function passed in this case must accept as parameters the \ectx
specialization for that context plus any arguments specified by that
specialization. It must return a tuple of that \ectx specialization plus the
same set of arguments.\footnote{But in the case
of \cpp{std::execution\_context<void>}, the return type is
simply \cpp{std::execution\_context<void>}.}

For purposes of discussion, consider two \cpp{std::execution\_context<void>}
instances: \cpp{mainctx} and \cpp{fctx}. Suppose that code running
on the program's main context instantiates \cpp{fctx} with function\\
\cpp{f(std::execution\_context<void> mainctx)} and calls \cpp{fctx()}, thereby
entering \cpp{f()}. This is the point at which \cpp{mainctx} is synthesized
and passed into \cpp{f()}.

Suppose further that after doing some work, \cpp{f()} calls \cpp{mainctx()},
thereby switching context back to the main context. \cpp{f()} remains
suspended in the call to \cpp{mainctx.operator()()}.

At this point the main context calls \cpp{fctx(std::invoke\_ontop\_arg, g);}
where \cpp{g()} is declared as:
\newline
\cpp{std::execution\_context<void> g(std::execution\_context<void> gmctx);}
\newline
\cpp{g()} is entered in the context of \cpp{f()}. It is as if \cpp{f()}'s call
to \cpp{mainctx.operator()()} directly called \cpp{g()}.

However, as usual, the \cpp{fctx.operator()()} call synthesizes a \ectx
instance representing the main context and passes it to \cpp{g()}
as \cpp{gmctx}.

Function \cpp{g()} has the same range of possibilities as any function called
on \cpp{f()}'s context. It can context-switch back to the main context, or to
any other reachable context. Its special invocation only matters when control
leaves it in either of two ways:

\begin{enumerate}
  \item If \cpp{g()} throws an exception, that exception unwinds all previous
  stack entries in that context (such as \cpp{f()}'s) as well, back to a
  matching \cpp{catch} clause.
  \item If \cpp{g()} returns, its return value becomes the value returned
  by \cpp{f()}'s suspended \cpp{mainctx.operator()()} call. This is
  why \cpp{g()}'s return type must be the same as that of \op, rather than
  that of an ordinary toplevel context function.
\end{enumerate}

Consider the following example:

\cppf{ontop}

Control passes from (a) to (b) to (c), and so on.

The \cpp{ctx(std::invoke\_ontop\_arg, f2, data+1)} call at (l) passes control
to \cpp{f2()} on the context originally created for \cpp{f1()}.

The \cpp{return} statement at (n) causes the \op call at (i) to return,
executing the assignment at (o). The \cpp{std::tuple} returned by \cpp{f2()}
is directly returned to that assignment at (o).

So in this example, the call at (l) synthesizes a \ectx instance representing
the main context and passes it to \cpp{f2()} as \cpp{ctx}. \cpp{f2()} returns
that \cpp{ctx} instance, which is received by \cpp{f1()} and assigned
to \emph{its} \cpp{ctx} variable. Finally, \cpp{f1()} returns its
own \cpp{ctx} variable, switching back to the main context.


\uabschnitt{Stack destruction}
On construction of \cpp{execution\_context} a stack is allocated. If the toplevel
context-function returns, the stack will be destroyed. If the context-function
has not yet returned and the destructor of a valid \cpp{execution\_context}
instance (\cpp{execution\_context::operator bool()} returns \cpp{true}) is
called, the stack will be unwound and destroyed.\footnote{An implementation is
free to unwind the stack without throwing an exception. However, if an
exception is thrown, it should be named \cpp{std::execution\_context\_unwind}.
Portable consumer code \emph{must} permit \cpp{std::execution\_context\_unwind}
exceptions to propagate, even if all other exceptions are caught
with \cpp{catch (...)}.}

The stack on which \cpp{main()} is executed, as well as the stack on which
the \emph{thread-function} passed to \cpp{std::thread}'s constructor is
executed, is allocated by the operating system. Such stacks are recognized by\\
\ectx, and are not deallocated by its destructor.

\uabschnitt{Stack allocators}
are used to create stacks. Stack allocators might implement arbitrary stack
strategies. For instance, a stack allocator might append a guard page at the
end of the stack or cache stacks for reuse or create stacks that grow on
demand.

\paragraph*{\emph{protected\_fixedsize}}
Constructs a linear stack of specified size,
appending a guard page at the end of each stack to protect against overflow.
If the guard page is accessed (read or write operation) a segmentation
fault/access violation is generated by the operating system.

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new stack allocator\\

\begin{tabular}{ l l }
    \midrule

    \cpp{protected\_fixedsize(std::size\_t size=default\_stacksize)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] fixed size stack, \cpp{size} determines the stack size
              (\cpp{default\_stacksize} is platform dependent)
\end{description}

{\bfseries Notes}
\newline
At the end of the protected stack a guard page is appended.

\paragraph*{\emph{fixedsize}}
Constructs a linear stack of specified size.
In contrast to \cpp{protected\_fixedsize}, it does not append a guard page at
the end of each stack. The memory is simply managed by \cpp{std::malloc()} and
\cpp{std::free()}.

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new stack allocator\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fixedsize(std::size\_t size=default\_stacksize)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] fixed size stack, \cpp{size} determines the stack size
              (\cpp{default\_stacksize} is platform dependent)
\end{description}

\paragraph*{\emph{segmented}}
Creates a segmented stack with the specified initial size, which
grows on demand.

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new stack allocator\\

\begin{tabular}{ l l }
    \midrule

    \cpp{segmented(std::size\_t size=default\_initial\_stacksize)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] stack grows on demand, \cpp{size} determines the initial stack size
              (\cpp{default\_initial\_stacksize} is platform dependent)
\end{description}


\uabschnitt{API}
declaration of class \ectx
\cppf{ec}
\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename StackAlloc, typename Fn, typename ...Params>}\\
    \cpp{execution\_context(std::allocator\_arg\_t, StackAlloc salloc,}\\
    \cpp{                   Fn&& fn, Params&& ...params)} & (2)\\

    \midrule

    \cpp{template<typename Fn, typename ...Params>}\\
    \cpp{explicit execution\_context(Fn&& fn, Params&& ...params)} & (3)\\

    \midrule

    \cpp{execution\_context(execution\_context&& other)} & (4)\\

    \midrule

    \cpp{execution\_context(const execution\_context& other)=delete} & (5)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor represents \emph{not-a-context}
    \item[2)] this constructor takes (e.g.) a lambda as argument, stack is
              constructed using \emph{salloc}
    \item[3)] takes (e.g.) lambda as argument,
              stack is constructed using either \cpp{fixedsize}
              or \cpp{segmented}. An implementation may infer which of these
              best suits the code in \cpp{fn}. If it cannot
              infer, \cpp{fixedsize} will be used.
    \item[4)] moves underlying capture record to new \ectx
    \item[5)] copy constructor deleted
\end{description}

{\bfseries Notes}
\newline
When an \ectx is constructed using either of the constructors accepting
\cpp{fn}, control is \emph{not} immediately passed to \cpp{fn}. Resuming
(entering) \cpp{fn} is performed by calling \cpp{operator()()} on the new
\ectx instance.\\

\subparagraph*{(destructor)}
destroys an execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution\_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal capture record, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the context object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution\_context& operator=(execution\_context&& other)} & (1)\\

    \midrule

    \cpp{execution\_context& operator=(const execution\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
resume context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{std::tuple<execution\_context, Args ...> operator()(Args ...args)} & (1)\\

    \midrule

    \cpp{execution\_context<void> operator()()} & (2) \\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{std::tuple<execution\_context, Args ...>}\\
    \cpp{operator()(invoke\_ontop\_arg\_t, Fn&& fn, Args ...args)} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{execution\_context<void>}\\
    \cpp{operator()(invoke\_ontop\_arg\_t, Fn&& fn)} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes the execution context
    \item[2)] specialization of (1) for \cpp{execution\_context<void>}
    \item[3)] suspends the active context, resumes the execution context but
        executes \cpp{fn(args ...)} in the resumed context (e.g. on top of the
        last stack frame)
    \item[4)] specialization of (3) for \cpp{execution\_context<void>}
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[... args] passed to current context  returned by the most recent call
                    to \cpp{execution\_context::operator()}\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[tuple]    of \cpp{execution\_context} and returned arguments passed to
                    the most recent call to\\ \cpp{execution\_context::operator()},
                    if any and a \cpp{execution\_context} representing the
                    context that has been suspended\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes toplevel \cpp{fn}\\
\end{description}

{\bfseries Notes}
\newline
The \emph{prologue} preserves the execution context of the calling context as
well as stack parts like \emph{parameter list} and \emph{return
address}.\footnote{required only by some x86 ABIs} Those data are restored by
the \emph{epilogue} if the calling context is resumed.
\newline
A suspended \cpp{execution\_context} can be destroyed. Its resources will be
cleaned up at that time.
\newline
The returned \cpp{execution\_context} indicates if the suspended context has
terminated (return from context-function) via \cpp{bool operator()}.
If the returned \cpp{execution\_context} has terminated no data are transferred
in the returned tuple.

\subparagraph*{operator bool}
test context if valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{explicit operator bool() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} refers to an valid \ectx,
              \cpp{false}\xspace otherwise
\end{description}

\subparagraph*{operator!}
test context if not valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator\!() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} refers not to an valid \ectx,
              \cpp{false}\xspace otherwise
\end{description}

\subparagraph*{any\_thread}
test if suspended context might be resumed on another thread\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool any\_thread() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} might be resumed on another thread,
              \cpp{false}\xspace otherwise
\end{description}
