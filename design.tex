\abschnitt{Design Decisions}

\subsubsection*{Proposed Design}
The design suggests two kinds of coroutines - \acoro and \scoro.\\
Symmetric coroutines usually occur in the context of concurrent programming in
order to represent independent units of execution. Implementations that produce
sequences of values typically use asymmetric coroutines \cite{Moura2009}.

\paragraph*{std::asymmetric\_coroutine<>::pull\_type:}
provides an asymmetric execution-transfer mechanism. This type transfers data
from another execution context (== pulled-from).\\
The class has only one template parameter defining the transferred parameter
type.\\
The constructor of \pullcoro takes a function (\corofunction) accepting a
reference to a \pushcoro as argument.\\
Instantiating a \pullcoro passes the control of execution to \corofunction and a
complementary \pushcoro is synthesized by the library and passed as reference to
\corofunction.\\
\newline
This kind of coroutine provides \pullcoroop - this method only switches context;
it transfers no data.\\
\newline
\pullcoro provides input iterators\\
(\pullcoroiterator) and \bgin/\ed are overloaded. The increment-operation
switches the context and transfers data.
\cppf{fibonacci.cpp}
In this example a \pullcoro is created in the main execution context taking a
lambda function (== \corofunction) which calculates Fibonacci numbers in a
simple \textit{for}-loop).\\
The \corofunction is executed in a newly created execution context which is
managed by the instance of\\
\pullcoro.\\
A \pushcoro is automatically generated by the library and passed as reference
to the lambda function. Each time the lambda function calls\\
\pushcoroop with another Fibonacci number,\\
\pushcoro transfers it back to the main execution context. The local state of
\corofunction is preserved and will be restored upon transferring execution
control back to \corofunction to calculate the next Fibonacci number.\\
Because \pullcoro provides input iterators and \bgin/\ed are overloaded, a
\textit{range-based for}-loop can be used to iterate over the generated
Fibonacci numbers.

\paragraph*{std::asymmetric\_coroutine<>::push\_type:}
provides an asymmetric execution-transfer mechanism. This type transfers data to
the other execution context (== pushed-to).\\
The class has only one template parameter defining the transferred parameter
type.\\
The constructor of \pushcoro takes a function (\corofunction) accepting a
reference to a \pullcoro as argument. In contrast to\\
\pullcoro, instantiating a \pushcoro does not pass the control of execution to
\corofunction{ }- instead the first call of\\
\pushcoroop synthesizes a complementary\\
\pullcoro and passes it as reference to \corofunction.\\
\newline
The \pushcoro interface does not contain a \get-function: you can not retrieve
values from another execution context with this kind of coroutine.\\
\newline
\pushcoro provides output iterators\\
(\pushcoroiterator) and \bgin/\ed are overloaded. The increment-operation
switches the context and transfers data.
\cppf{layout.cpp}
In this example a \pushcoro is created in the main execution context accepting
a lambda function (== \corofunction) which requests strings and lays
out \textit{num} of them on each line.\\
This demonstrates the inversion of control permitted by coroutines. Without
coroutines, a utility function to perform the same job would necessarily
accept each new value as a function parameter, returning after processing that
single value. That function would depend on a static state variable. A
\corofunction, however, can request each new value as if by calling a function
-- even though its caller also passes values as if by calling a function.\\
The \corofunction is executed in a newly created execution context which is
managed by the instance of\\
\pushcoro.\\
The main execution context passes the strings to the
\corofunction by calling\\
\pushcoroop.\\
A \pullcoro is automatically generated by the library and passed as reference
to the lambda function. The \corofunction accesses the strings passed
from the main execution context by calling\\
\pullcoroget and lays those
strings out on \cpp{std::cout} according the parameters \textit{num} and \textit{width}.\\
The local state of \corofunction is preserved and will be restored after
transferring execution control back to \corofunction.\\
Because \pushcoro provides output iterators and \bgin/\ed are overloaded, the
\cpp{std::copy} algorithm can be used to iterate over the vector containing the
strings and pass them one by one to the coroutine.

\paragraph*{std::symmetric\_coroutine<>::call\_type:}
provides a symmetric execution-transfer mechanism. This type transfers data to
the other execution context.\\
The class has only one template parameter defining the transferred parameter
type.\\
\newline
\callcoro starts a symmetric coroutine and transfers its parameter to its
\corofunction. The template parameter defines the transferred parameter
type. The constructor of\\
\callcoro takes a function (coroutine-function) accepting a reference to a\\
\yieldcoro as argument. Instantiating a \callcoro does not pass the control of
execution to \corofunction{ }- instead the first call of\\
\callcoroop synthesizes a \yieldcoro and passes it as reference to \corofunction.\\
The \callcoro interface does not contain a \get-function.\\
\newline
In contrast to \acoro, where the relationship between caller and callee is
fixed,\\
\scoro is able to transfer execution control to any other (symmetric) coroutine.
That is, a \scoro is not required to return to its direct caller.\\
\newline
A \yieldcoro is automatically generated by the library and passed as reference
to the \corofunction. The \corofunction accesses the data passed to it by calling\\
\yieldcoroget.\\
The local state of \corofunction is preserved and will be restored after
transferring execution control back to \corofunction.\\

\paragraph*{std::symmetric\_coroutine<>::yield\_type:}
provides a symmetric execution-transfer mechanism. This type transfers control
to another execution-context.\\
\yieldcoroop is used to transfer data and execution control to another context
by calling \yieldcoroop with another\\
\callcoro as first argument. Alternatively, you may transfer control back to the
code that called \callcoroop by calling\\
\yieldcoroop without a \callcoro argument.\\
\newline
The class has only one template parameter defining the transferred parameter
type. Data transferred to the coroutine are accessed through \yieldcoroget.\\
\newline
Instances of this coroutine type can be created by the library only.
\cppf{merge.cpp}
In this example two \callcoro are created in the main execution context
accepting a lambda function (== coroutine-function) which merges elements of two
sorted arrays into a third array. \cpp{coro_a()} enters the \corofunction of
\cpp{coro_a} cycling through the array and testing if the actual element in the
other array is less than the element in the local one. If so, the coroutine
yields to the other coroutine \cpp{coro_b} using \cpp{yield(*other_b)}. If the
current element of the local array is less than the element of the other array,
it is put to the third array. Because the coroutine jumps back to \cpp{coro_a()}
(returning from this method) after leaving the coroutine-function, the elements
of the other array will appended at the end of the third array if all element of
the local array are processed. 

\paragraph*{stackful:}
Each instance of a coroutine has its own stack.\\
\newline
In contrast to stackless coroutines, stackful coroutines allow invoking the
suspend operation out of arbitrary sub-stackframes, enabling \escreops.

\paragraph*{move-only:}
A coroutine is moveable-only.\\
\newline
If it were copyable, then its stack with all the objects allocated on it
would be copied too. That would force undefined behaviour if some of these objects
were RAII-classes (manage a resource via RAII pattern). When the first of the
coroutine copies terminates (unwinds its stack), the RAII class destructors will
release their managed resources. When the second copy terminates, the same
destructors will try to doubly-release the same resources, leading to undefined
behavior.

\paragraph*{clean-up:}
On coroutine destruction the associated stack will be unwound.\\
\newline
The implementer is free to deallocate the stack or cache it for future usage
(for coroutines created later).

\paragraph*{segmented stack:}
\acoro and \scoro must support segmented stacks (growing on demand).\\
\newline
It is not always possible to accurately estimate the required stack size - in
most cases too much memory is allocated (waste of virtual address-space).\\
At construction a coroutine starts with a default (minimal) stack size.\\
At this time of writing only GCC version 4.7 or higher\cite{gccsplit} and
clang version 3.4 or higher are known to support
segmented stacks. With version 1.54 \boostcoroutine provides support for
segmented stacks.\\

\paragraph*{context switch:}
A coroutine saves and restores registers according to the underlying ABI on
each context switch.\\
\newline
This also includes the floating point environment as required by the ABI. The
implementer can omit preserving the floating point environment if he can predict that
it's safe.\\
On POSIX systems, a coroutine context switch must not preserve signal masks for performance
reasons.\\
A context switch is done via \pushcoroop,\\
\pullcoroop for asymmetric coroutines and\\
\callcoroop,\\
\yieldcoroop for symmetric coroutines.

\paragraph*{coroutine-function:}
The \corofunction returns \cpp{void} and takes its counterpart-coroutine as
argument, so that using the coroutine passed as argument to \corofunction is the
only way (besides simply returning) to transfer data and execution control to
another execution context.\\
\newline
For \pullcoro the \corofunction is entered at\\
\pullcoro construction.
For \pushcoro the \corofunction is not entered at \pushcoro construction but
entered by the first invocation of \pushcoroop.\\
\newline
For \callcoro the \corofunction is not entered at\\
\callcoro construction but entered by the first invocation of\\
\callcoroop.\\
\yieldcoro are always synthesized by the framework.\\
After execution control is returned from \corofunction the state of the
coroutine can be checked via\\
\pullcorobool,\\
\pushcorobool and\\
\callcorobool returning \cpp{true} if the coroutine is still valid (\corofunction has
not terminated).
\newline
Unless \cpp{T} is \cpp{void}, \pullcorobool returning \cpp{true} also implies
that a data value is available.\\
\newline
Unless \cpp{T} is void, the \corofunction of a \callcoro
can assume that (a) upon initial entry and (b) after every\\
\yieldcoroop call, \yieldcoroget has a new value available.\\
However, if \cpp{T} is a move-only type, \yieldcoroget may
only be called once before the next \yieldcoroop call.

\paragraph*{passing data from a pull-coroutine to main-context:}
In order to transfer data from a\\
\pullcoro to the main-context the framework synthesizes a\\
\pushcoro associated
with the \pullcoro instance in the main-context. The synthesized\\
\pushcoro is passed as argument to \corofunction.\\
The \corofunction must call this \pushcoroop in order to transfer each
data value back to the main-context.\\
In the main-context, the \pullcorobool determines whether the coroutine is still
valid and a data value is available or \corofunction has terminated\\
(\pullcoro is invalid; no data value available). Access to the transferred data
value is given by \pullcoroget.
\cppf{data_to_main.cpp}

\paragraph*{passing data from main-context to a push-coroutine:}
In order to transfer data to a\\
\pushcoro from the main-context the framework synthesizes a\\
\pullcoro associated with the \pushcoro instance in the main-context. The
synthesized \pullcoro is passed as argument to \corofunction.\\
The main-context must call this \pushcoroop in order to transfer each data value
into the \corofunction.\\
Access to the transferred data value is given by \pullcoroget.
\cppf{data_from_main.cpp}

\paragraph*{passing data to a symmetric-coroutine:}
In order to transfer data to a\\
\callcoro from the main-context the framework synthesizes a\\
\yieldcoro associated with the \callcoro instance in the main-context. The
synthesized\\
\yieldcoro is passed as argument to \corofunction.\\
The main-context must call this \callcoroop in order to transfer each data value
into the \corofunction.\\
Access to the transferred data value is given by \yieldcoroget.
\cppf{data_from_call.cpp}

\paragraph*{accessing parameters:}
Parameters returned from or transferred to the \corofunction can be accessed
with \pullcoroget or \yieldcoroget.\\
\newline
Splitting-up the access of parameters from context switch function enables to
check if\\
\pullcoro is valid after return from\\
\pullcoroop, e.g. \pullcoro has values and \corofunction has not terminated.
\cppf{access_params_asym.cpp}
Parameters passed via \callcoro are accessed via\\
\yieldcoroget inside the symmetric coroutine.
\cppf{access_params_sym.cpp}

\paragraph*{exceptions:}
An exception thrown inside a \pullcoro's \corofunction before its first call to
\pushcoroop will be re-thrown by the \pullcoro constructor. After a \pullcoro's
\corofunction's first call to\\
\pushcoroop, any subsequent exception inside that \corofunction will be
re-thrown by \pullcoroop.\\
\newline
An exception thrown inside a \pushcoro's \corofunction will be re-thrown by
\pushcoroop.\\
\newline
An uncaught exception inside a \callcoro's \corofunction will call\\
\cpp{std::terminate()}.

\paragraph*{exit a \corofunction:}
A \corofunction is exited with a simple return statement.
\newline
Returning from a \pullcoro's \corofunction jumps back to the main-context that
invoked it. If the \corofunction did not execute \pushcoroop, control resumes
after the \pullcoro's constructor. If the \corofunction has
executed \pushcoroop, control resumes after the most recent \pullcoroop. From
that point on,\\
\pullcorobool will return \cpp{false}.
\newline
Returning from a \pushcoro's \corofunction jumps back to the main-context that
invoked it. Control resumes after the most recent \pushcoroop. From that point
on, \pushcorobool will return \cpp{false}.
\newline
Returning from a \callcoro's \corofunction jumps back to the calling\\
\callcoroop at the start of symmetric coroutine chain. That is,
symmetric coroutines do not have a strong, fixed relationship to the caller as
asymmetric coroutines do. From that point on, \callcorobool will
return \cpp{false}.


\subsubsection*{Other libraries and proposals}
\paragraph*{Mordor:}
Mordor\cite{mordor} is another C++ library implementing cooperative multitasking
in order to achieve high I/O performance. The difference from this design is
that this proposal focuses on enhanced control flow, while Mordor\cite{mordor}
abstracts on the level of tasking: providing a cooperatively scheduled fiber
engine.

\paragraph*{AT\&T Task Library:}
Another design of a task library was published by AT\&T\cite{atnt1989}
describing a tasking system with non-preemptive scheduling.\\
\pushcoro/\pullcoro does not provide scheduling logic but could be used as the
basic mechanism for such a tasking abstraction.

\paragraph*{boost.fiber:}
\boostfiber uses symmetric coroutines in order to support cooperative multi-tasking.
The interface is similar to \cpp{std::thread}, e.g. synchonization primitives
like \cpp{mutex},\cpp{condition_variable} and \cpp{future} are provided.

\paragraph*{C++ proposal: resumable functions (N3328\cite{n3328}):}
This proposal is a library superset of N3328: the \resumfn can be implemented
on top of coroutines. The proposed coroutine library does not require memory allocation
for the future on a context switch and does not require language changes (no keywords
like \textit{resumable} and \textit{await}).\\
As described in N3328 section 3.2.5 'Function Prolog' - the body of a \resumfn is
transformed into a switch statement. This is similar to the stackless coroutines
of Python and C\#.\\
A proof-of-concept how \await could be built upon \boostcoroutine has already been
implemented in \awaitemu.\\
\newline
Without stackfulness and first-class semantics, some useful execution control
flows cannot be supported (for instance cooperative multitasking,
checkpointing) and recursive problems such as the 'same fringe' example become
much more difficult.

\paragraph*{C++ proposal: Library Foundations for Asynchronous Operations,
Revision 1
(N3964\cite{n3964}):}
N3964 discusses how \boostasio's generalized \cpp{CompletionToken} support
facilitates integrating asynchronous operations with coroutines and fibers.
The paper proposes this mechanism for use in any asychronous library functions.
