\abschnitt{Design}
The design of \ectx is based on N4397\cite{N4397} with one modification - the
i\emph{lambda-like expression} does not have the \emph{hint} attribute.\\
Instead the compiler desides if one activation records is sufficient
(\emph[stackless} or a side stack is required (\emph{stackful}. The compiler 
makes the desicion based on the analyzation of the toplevel cotnext function.
If the compiler can prove, that context switches are only done at the toplevel
function and not from nested call stack (from subroutines), than a
\emph{stakcless} execution cotnext is created. Otherwise the compiler constructs
a \ectx with a non-contiguous, linked side stack. The initial defaul stacksize
depends on the platform.

\uabschnitt{First-class object}
As first-class object the execution context can be stored in a variable or
container.

\uabschnitt{Capture record}
Each instance of \ectx owns a toplevel activation record, the capture record.
The capture record is a special activation record that stores addtional data
like stack pointer, instruction pointer and a link to its parent execution
context. That means that during a execution context switch, the execution state
of the running context is captured and stored in the capture record while the
content of the resumed execution context is loaded (into CPU registers etc.).

\paragraph*{Parent context}
The pointer to its \emph{parent} execution context allows to traverse the chain
of ancestor context's, e.g. the execution context which has resumed (\ectxop
called) the running context.

\paragraph*{Active context}
Static member function \ectxcurrent returns a \ectx pointing to the current
capture record (e.g. execution context). The current active capture record is
stored in an internal, thread local pointer.

\paragraph*{Toplevel capture records}
At entering \main as well as the \emph{thread-function} of a thread, a execution
context (capture record) is created and stored in the internally.
\ectxcurrent.

\uabschnitt{Suspend-on-call}
\ectx is designed to suspend on call of \ectxop. The \emph{prolog} of \ectxop
captures (preserves) the active execution context and loads the data from the
capture record of the resumed context (e.g. \ectxop called on \emph{*this}) into
the CPU.\\
The previous running context becomes the parent of the resumed context and gets
suspended. Thus forming a parent-child relationship between suspended and
resumed context. The parent may vary between successive calls of \ectxop.\\
As described in section Discussion, \ectxop cleans up the stack of the calling
context. That means that parts, like \emph{parameter list} and \emph{return
address}, are poped from the caller stack and preserved in the \emph{capture
record} of the calling context. If this cotnext is resumed, then the preserved
stack data (\emph{parameter list} and \emph{return address}) are restored (
pushed to the stack) so that the calling convetion is not violated. For the
code it looks like returning from \ectxop. The code can not decide if \ectxop
triggers and \emph{stackless} or \emph{stackful} context switch, nor can the
code distinghuish \ectxop from ordinary function calls.

\paragraph*{Termination}
If the body of the toplevel context function reaches its end, the parent
execution context (pointer in the capture record) is resumed. That means that
in the parent context the function \ectxop returns. For this purpose the
\emph{epilog} of \ectxop loads the capture record (instruction pointer, stack
pointer etc.) of the parent context, so that it is resumed.

\uabschnitt{Exceptions}
A exception thrown inside the execution context is catched, the parent execution
context is resumed and the exception is re-thrown inside the parent context
(e.g. the exception is emitted by \ectxop).

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new execution context\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}[captures](params) {\color{blue}mutable} {\color{blue}resumable} {\color{blue}exceptions} attrs -> ret \{body\}} & (1)\\

    \midrule

    \cpp{execution_context(const execution_context& other)=default} & (2)\\

    \midrule

    \cpp{execution_context(execution_context&& other)=default} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] the constructor does not take a lambda as argument, instead the
              compiler evaluates the lambda-like syntax and constructs a \ectx
              directly
              \begin{description}
                  \item[captures]     list of captures
                  \item[params]       only empty parameter-list allowed
                  \item[mutable]      allows to modify parameters captured by copy
                  \item[resumable]    identify resumable context
                  \item[exceptions]   only \cpp{noexcept} allowed; emitted exceptions
                                      trigger \cpp{std::terminate()}
                  \item[attrs]        attributes for \cpp{operator()}
                  \item[ret]          only \cpp{void} allowed; resumable lambda returns nothing
                                      (use of capture list instead)
                  \item[body]         function body\\
              \end{description}
    \item[2)] copies \ectx, e.g. underlying control block is shared
    \item[3)] moves underlying control block to new \ectx
\end{description}

\subparagraph*{(destructor)}
destroys a execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~execution_context()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \ectx. If associated with a context of execution and
              holds the last reference to the internal control block, then the
              context of execution is destroyed too. Specifically, the stack is
              unwound.\\
\end{description}

\subparagraph*{operator=}
copies/moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{execution_context& operator=(execution_context&& other)} & (1)\\

    \midrule

    \cpp{execution_context& operator=(const execution_context& other)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \emph{other} to \emph{*this} using move semantics
    \item[2)] copies the state of \emph{other} to \emph{*this}, state (control block)
              is shared
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}execution\_context\& {\color{blue}operator}()()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] resumes the execution context\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] re-throws the exception of the resumed context in the parent context\\
\end{description}

{\bfseries Notes}
\newline
The \emph{prolog} preserves the exectuin context of the calling context as well
as stack parts like \emph{parameter list} and \emph{return address}
\footnote{required only by some x86 ABIs}. Those data are restored by the
\emph{epilog} if the callign context is resumed.
\newline
A exception thrown inside execution context is catched, the parent execution
context is resumed and the exception is re-throw in the parent context (out of
\ectxop).\\
If the toplevel context function terminates (reaches end), the parent context is
resumed (return of\\
\ectxop in the parent execution context).\\
The behaviour is undefined if \cpp{operator()} is called while \cpp{current()}
returns \emph{*this} (e.g. resuming an already running context).

\subparagraph*{explicit bool operator}
test if context has not reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}explicit} {\color{blue}bool} {\color{blue}operator}() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is not terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator!}
test if context has reached its end\\

\begin{tabular}{ l l }
    \midrule

    {\ttfamily\small\color{black}{\color{blue}bool} {\color{blue}operator}!() {\color{blue}noexcept}} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \emph{true} if context is terminated\\
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{current}
accesses the current active execution context\\

\begin{tabular}{ l l }
    \midrule

    \cpp{static execution_context current()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] construct a instance of \ectx pointing to the capture record of
              the current, active execution context\\
\end{description}

{\bfseries Notes}
\newline
The current active execution context is thread-specific, e.g. for each thread
(including \main) a execution context is created at start-up.
