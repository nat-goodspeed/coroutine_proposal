\abschnitt{Motivation}

This proposal referes to \boostcoroutine as reference implementation - providing
a test suite and examples (some are described in this section).\\
\newline
In order to support a broad range of execution control behaviour \pushcoro and
\pullcoro can be used to \escrecloops, to \escreccomps~and for \coopmultitasking
helping to solve problems in a much simpler and more elegant way than with only
a single flow of control.\\

\subsubsection*{same fringe problem}
Advantages can be seen particularly clearly with the use of a recursive
function, such as traversal of trees.\\
If two trees have the same list of leave nodes (== fringe) and traversing the
trees is defined in a deterministic order, then both trees have the same fringe.\\

\imgc{fringe.pdf}

Both trees in the picture have the same fringe even if the structure of the trees
is different.\\
\newline
The same fringe problem could be solved using coroutines by iterating over the
leaf nodes and comparing this sequence via \cpp{std::equal()}. The range of leaf
nodes is generated by a visitor which recursively traverses the tree and passes
leaf nodes to its coroutine.\\
\newline
\cppf{fringe.cpp}
A tree consists of branch and leaf nodes. Each branch node has two children;
leaf nodes have none. Trees t1 and t2 have a different tree structure but the
same fringe.\\
For each tree a \pullcoro is created while in the associated \corofunction
\cpp{coro_visitor} traverses the tree.\\
\coroiterator, created from \pullcoro, steps over the leaf nodes of its tree and
\cpp{std::equal()} compares the iterator ranges.
\newline
\newline
\cppf{visitor.cpp}
The visitor inspects recursively the tree - on each leaf node it escapes the
recursive computation and makes the leaf node available to the iterator (via
\pushcoro). After re-entering the visitor the recursive traversing of the tree
continues.
\subsubsection*{asynchronous operations with boost.asio}
In the past the code using asio's \asyncops was scattered by callbacks.
\boostasio provides with its new feature \asyncres a new way how the code can be
simplified and made easier to read.\\
\yieldcontext uses internally \boostcoroutine:
\cppf{asyncres.cpp} 

\subsubsection*{\csharp \await}
Another project, \awaitemu, uses \boostcoroutine for a proof-of-concept
providing a full emulation of the \csharp feature \await as a library
extension. Because of stackfull coroutines \await is \textbf{not limited} by
"one level" as in \csharp.\\
Evgeny Panasyuk describes the advantages of \boostcoroutine over \await at
\channelnine.
\cppf{await.cpp}
