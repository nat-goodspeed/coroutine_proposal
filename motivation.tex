\abschnitt{Motivation}

This proposal refers to \boostcoroutine as reference implementation - providing
a test suite and examples (some are described in this section).\\
\newline
In order to support a broad range of execution control behaviour \pushcoro and\\
\pullcoro can be used to \escrecloops, to \escreccomps~and for \coopmultitasking
helping to solve problems in a much simpler and more elegant way than with only
a single flow of control.

\subsubsection*{'same fringe' problem}
The advantages can be seen particularly clearly with the use of a recursive
function, such as traversal of trees.\\
If traversing two different trees in the same deterministic order produces the
same list of leaf nodes, then both trees have the same fringe even if the tree
structure is different.\\
\newline
The same fringe problem could be solved using coroutines by iterating over the
leaf nodes and comparing this sequence via \cpp{std::equal()}. The range of data
values is generated by function \cpp{traverse()} which recursively traverses the
tree and passes each node's data value to its \pushcoro.\\
\pushcoro suspends the recursive computation and transfers the data value to
the main execution context.\\
\pullcoroiterator, created from \pullcoro, steps over those data values and
delivers them to \cpp{std::equal()} for comparison. Each increment of \pullcoroiterator
resumes \cpp{traverse()}. Upon return from \cpp{iterator::operator++()}, either
a new data value is available, or tree traversal is finished (iterator is
invalidated).
\cppf{same_fringe.cpp}

\subsubsection*{asynchronous operations with boost.asio}
In the past the code using asio's \asyncops was scattered by callbacks.
\boostasio provides with its new \asyncres feature a new way to simplify the
code and make it easier to read.\\
Proposal 'N3747: A Universal Model for Asynchronous Operations'\cite{n3747}
describes the usage of coroutines in the context of asynchronous operations.\\
\yieldcontext uses internally \boostcoroutine:
\cppf{asyncres.cpp} 

\subsubsection*{\csharp \await}
\csharp contains the two keywords \async and \await. \async introduces a
control flow that involves awaiting asynchronous operations. The compiler
reorganizes the code into a continuation-passing style. \await wraps the rest
of the function after calling \await into a continuation if the asynchronous
operation has not yet completed.\\
The project \awaitemu uses \boostcoroutine for a proof-of-concept
demonstrating the implementation of a full emulation of \csharp \await as a
library extension. Because of stackful coroutines \await is \textbf{not limited}
by "one level" as in \csharp.\\
Evgeny Panasyuk describes the advantages of \boostcoroutine over \await at
\channelnine.
\cppf{await.cpp}
