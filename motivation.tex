\abschnitt{Motivation and Scope}

This proposal referes to \boostcoroutine as reference implementation - providing
a test suite and examples.\\
\newline
\coro can be used to \escrecloops, to \escreccomps~and for \coopmultitasking~helping
to solve problems in a much simpler and more elegant way than with only a single
flow of control.\\
Advantages can be seen particularly clearly with the use of a recursive function,
such as traversal of binary trees.

\subsubsection*{same fringe problem}

If two trees have the same list of leave nodes (== fringe) and traversing the
trees is defined in a deterministic order, then both trees have the same fringe.\\

\imgc{fringe.pdf}

Both trees in the picture have the same fringe even if the structure of the trees
is different.\\
\newline
The same fringe problem could be solved using \coro by iterating over the leaf
nodes and comparing this sequence via \cpp{std::equal()}. The range of leaf
nodes is generated by a visitor which recursively traverses the tree and passes
leaf nodes to its \coro.\\
\newline
\cppf{fringe.cpp}
A tree consists of branch and leaf nodes. Each branch node has two children; leaf
nodes have none. Trees t1 and t2 have a different tree structure but the same fringe.\\
For each tree a \coro is created while in the associated \corofunction \cpp{coro_visitor}
traverses the tree.\\
For each tree a \coro is created and \coroiterator steps over the leaf nodes of
its tree. \cpp{std::equal()} compares the iterator ranges.
\newline
\cppf{visitor.cpp}
The visitor inspects recursively the tree - on each leaf node it escapes the recursive
computation and makes the leaf node available to the iterator. After re-entering the
visitor the recursive traversing of the tree continues.
\newline
The complete source code is contained in the examples of \boostcoroutine.
