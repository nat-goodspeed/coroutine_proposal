\abschnitt{Technical Specification}

\subsubsection*{pull-coroutine:}
\cppf{pull_coroutine.cpp}

\paragraph*{(constructor):}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type();} & (1)\\

    \midrule

    \cpp{pull_type(Function&& fn,std::size_t ssize=min_ssize);} & (2)\\

    \midrule

    \cpp{pull_type(Function&& fn,const StackAllocator& salloc,std::size_t ssize=min_ssize);} & (3)\\

    \midrule

    \cpp{pull_type(pull_type&& other);} & (4)\\

    \midrule

    \cpp{pull_type(const pull_type& other)=delete;} & (5)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pullcoro which does not represent a context of execution
    \item[2)] creates a \pullcoro object and associates it with a execution
              context
    \item[3)] creates a \pullcoro object and associates it with a execution
              context
    \item[4)] move constructor, constructs a \pullcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[5)] copy constructor is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]  another coroutine object to construct this coroutine object with
    \item[fn]     function to execute in the new coroutine
    \item[ssize]  size of the stack managed by the coroutine (min\_ssize is the
                  minimal size of a stack, platform depended), might grow on demand
    \item[salloc] allocator for stack, might use cached stacks for performance
                  reasons
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 4)] noexcept specification: \cpp{noexcept}
    \item[2), 3)] \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction
\end{description}

{\bf Notes}
Return values from the \corofunction are accessible via \pullcoroget. If the
function throws an exception, this exception is re-thrown if the caller returns
from \pullcoroop.\\

{\bf Example}
\cppf{fibonacci.cpp}

\paragraph*{(destructor):}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~pull_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pullcoro, if associated with a context of execution,
              then the context of execution is destroyed too (for instance the
              associated stack)\\
\end{description}

\paragraph*{operator=:}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator=(pull_type&& other);} & (1)\\

    \cpp{pull_type & operator=(const pull_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
    \item[2)] assignment operator is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator bool:}
indicates if context of execution is still valid and a return value can be
retrieved or \corofunction has finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine has a return value and is not
              complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator():}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator()();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfer control of execution to \corofunction and makes them
              accessible by \pullcoroget
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\paragraph*{get:}
accesses the return value from \corofunction\\

\begin{tabular}{ l l }
    \midrule

    \cpp{R get();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] access values returned from \corofunction
\end{description}

{\bf Return value}
\begin{description}
    \item[R] return type is defined by coroutines template argument
\end{description}


\paragraph*{swap:}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}


\subsubsection*{push-coroutine:}
\cppf{push_coroutine.cpp}

\paragraph*{(constructor):}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type();} & (1)\\

    \midrule

    \cpp{push_type(Function&& fn,ssize_t ssize=min_ssize);} & (2)\\

    \midrule

    \cpp{push_type(Function&& fn,const StackAllocator& salloc,std::size_t ssize=min_ssize);} & (3)\\

    \midrule

    \cpp{push_type(push_type&& other);} & (4)\\

    \midrule

    \cpp{push_type(const push_type& other)=delete;} & (5)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pushcoro which does not represent a context of
              execution
    \item[2)] creates a \pushcoro object and associates it with a execution
              context
    \item[3)] creates a \pushcoro object and associates it with a execution
              context
    \item[4)] move constructor, constructs a \pushcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[5)] copy constructor is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other] another coroutine object to construct this coroutine object
                 with
    \item[fn]    function to execute in the new coroutine
    \item[ssize]  size of the stack managed by the coroutine (min\_ssize is the
                  minimal size of a stack, platform depended), might grow on demand
    \item[salloc] allocator for stack, might use cached stacks for performance
                  reasons
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2))]    \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction
\end{description}

{\bf Notes}
If the function throws an exception, this exception is re-thrown if the caller
returns from \pushcoroop.\\

{\bf Example}
\cppf{access_params.cpp}

\paragraph*{(destructor):}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~push_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pushcoro, if associated with a context of execution,
              then the context of execution is destroyed too (for instance the
              associated stack)
\end{description}

\paragraph*{operator=:}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type & operator=(push_type&& other);} & (1)\\

    \cpp{push_type & operator=(const push_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
    \item[2)] assignment operator is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator bool:}
indicates if context of execution is still valid, e.g. \corofunction has not
been finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine has a return value and is not
              complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator():}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type & operator()(Arg&& arg);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] switches the context of execution and transfers arg to
              \corofunction and makes them accessible
\end{description}

{\bf Parameters}
\begin{description}
    \item[arg] argument to pass to the \corofunction
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\paragraph*{swap:}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}
