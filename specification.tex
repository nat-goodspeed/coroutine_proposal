\abschnitt{Technical Specification}

\subsubsection*{pull-coroutine:}
\cppf{pull_coroutine.cpp}

\paragraph*{(constructor):}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_coroutine();} & (1)\\

    \midrule

    \cpp{pull_coroutine(Function&& fn);} & (2)\\

    \midrule

    \cpp{pull_coroutine(pull_coroutine&& other);} & (3)\\

    \midrule

    \cpp{pull_coroutine(const pull_coroutine& other) = delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pullcoro which does not represent a context of execution
    \item[2)] creates a \pullcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pullcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to construct this coroutine object with
    \item[fn]      function to execute in the new coroutine
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2)]     \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction
\end{description}

{\bf Notes}
Return values from the \corofunction are accessible via \pullcoroget. If the
function throws an exception, this exception is re-thrown if the caller returns from
\coroop.\\

{\bf Example}
\cppf{fibonacci.cpp}

\paragraph*{(destructor):}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~pull_coroutine();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pullcoro, if associated with a context of execution, then
              the context of execution is destroyed too (for instance the
              associated stack)\\
\end{description}

\paragraph*{operator=:}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_coroutine & operator=(pull_coroutine&& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator bool:}
indicates if context of execution is still valid and a return value can be
retrieved or \corofunction has finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine has a return value and is not
              complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator():}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_coroutine & operator()();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfer control of execution to \corofunction and makes them
              accessible by \coroget
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\paragraph*{get:}
accesses the return value from \corofunction\\

\begin{tabular}{ l l }
    \midrule

    \cpp{R get();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] access values returned from \corofunction
\end{description}

{\bf Return value}
\begin{description}
    \item[R] return type is defined by coroutines template argument
\end{description}


\paragraph*{swap:}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_coroutine& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}


\subsubsection*{push-coroutine:}
\cppf{push_coroutine.cpp}

\paragraph*{(constructor):}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_coroutine();} & (1)\\

    \midrule

    \cpp{push_coroutine(Function&& fn);} & (2)\\

    \midrule

    \cpp{push_coroutine(push_coroutine&& other);} & (3)\\

    \midrule

    \cpp{push_coroutine(const push_coroutine& other) = delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pushcoro which does not represent a context of
              execution
    \item[2)] creates a \pushcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pushcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutine are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other] another coroutine object to construct this coroutine object
                 with
    \item[fn]    function to execute in the new coroutine
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2))]    \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction
\end{description}

{\bf Notes}
If the function throws an exception, this exception is re-thrown if the caller
returns from \pushcoroop.\\

{\bf Example}
\cppf{access_params.cpp}

\paragraph*{(destructor):}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~push_coroutine();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pushcoro, if associated with a context of execution,
              then the context of execution is destroyed too (for instance the
              associated stack)
\end{description}

\paragraph*{operator=:}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_coroutine & operator=(push_coroutine&& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator bool:}
indicates if context of execution is still valid, e.g. \corofunction has not
been finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine has a return value and is not
              complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{operator():}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_coroutine & operator()(Arg&& arg);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] switches the context of execution and transfers arg to
              \corofunction and makes them accessible
\end{description}

{\bf Parameters}
\begin{description}
    \item[arg] argument to pass to the \corofunction
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\paragraph*{swap:}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_coroutine& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}
