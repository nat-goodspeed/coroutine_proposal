\abschnitt{Technical Specification}

\subsubsection*{std::coroutine<>::pull\_type}
Defined in header \cpp{<coroutine>}.\\
\begin{tabular}{ l }
    \midrule

    \cpp{template<class T> class coroutine<T>::pull_type;}\\

    \midrule

    \cpp{template<class T> class coroutine<T&>::pull_type;}\\

    \midrule

    \cpp{template<> class coroutine<void>::pull_type;}\\

    \midrule
\end{tabular}
\newline
The class \pullcoro provides a mechanism to access data values transferred from
one execution context to another.

\paragraph*{member types\\}
\begin{tabular}{ l l l }
    \midrule

    \cpp{iterator} & std::input\_iterator & (not defined for coroutine<void>::pull\_type template specialization)\\

    \midrule
\end{tabular}

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type();} & (1)\\

    \midrule

    \cpp{pull_type(Function&& fn);} & (2)\\

    \midrule

    \cpp{pull_type(pull_type&& other);} & (3)\\

    \midrule

    \cpp{pull_type(const pull_type& other)=delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pullcoro which does not represent a context of execution
    \item[2)] creates a \pullcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pullcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutines are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]  another coroutine object with which to construct this coroutine object
    \item[fn]     function to execute in the new coroutine
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2)] \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction
\end{description}

{\bf Notes}
Return values from the \corofunction are accessible via \pullcoroget.\\
If the \corofunction throws an exception, this exception is re-thrown when the caller
returns from\\
\pullcoroop.\\

{\bf Example}
\cppf{fibonacci.cpp}

\subparagraph*{(destructor)}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~pull_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pullcoro. If that \pullcoro is associated with a context of execution,
              then the context of execution is destroyed too. Specifically,
              its stack is unwound.\\
\end{description}

\subparagraph*{operator=}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator=(pull_type&& other);} & (1)\\

    \midrule

    \cpp{pull_type & operator=(const pull_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
    \item[2)] copy assignment is deleted; coroutines are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{operator bool}
indicates whether context of execution is still valid and a return value can be
retrieved, or \corofunction has finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine has a return value and is not
              complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator()();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfer control of execution to \corofunction
\end{description}
It is important that the coroutine is valid (using \cpp{operator bool()}) befor
calling this function.\\

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\subparagraph*{get}
accesses the current value from \corofunction\\

\begin{tabular}{ l l l }
    \midrule

    \cpp{R get();} & (1) & (member of generic template)\\

    \midrule

    \cpp{R& get();} & (2) & (member of generic template)\\

    \midrule

    \cpp{void get()=delete;} & (3) & (only for coroutine<void>::pull\_type template specialization)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] access values returned from \corofunction (if move-assignable, the
              value is moved, otherwise copied)
    \item[2)] access reference returned from \corofunction
\end{description}
It is important that the coroutine is valid (using \cpp{operator bool()}) befor
calling this function.\\

{\bf Return value}
\begin{description}
    \item[R] return type is defined by coroutine's template argument
    \item[void] coroutine returns nothing
\end{description}

\subparagraph*{swap}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{non-member functions}
\subparagraph*{std::swap}
Specializes \cpp{std::swap} for \pullcoro and swaps the underlying context of
lhs and rhs.

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_type& lhs,pull_type& rhs);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects by calling \cpp{lhs.swap(rhs)}. 
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{std::begin}
Specializes \cpp{std::begin} for \pullcoro.

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::pull_type::iterator begin(coroutine<R>::pull_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns a \cpp{std::input_iterator}
\end{description}

\subparagraph*{std::end}
Specializes \cpp{std::end} for \pullcoro.

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::pull_type::iterator end(coroutine<R>::pull_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns an \cpp{std::input_iterator} indicating the termination of the \corofunction
\end{description}

Incrementing the iterator switches the execution context.
\newline
When a main-context calls \cpp{iterator::operator++()} on an iterator obtained
from an explicitly-instantiated\\
\pullcoro, it must compare the incremented
value with the iterator returned by \cpp{std::end()}. If they are unequal, the
\corofunction has passed a new data value, which can be accessed via
\cpp{iterator::operator*()}. Otherwise the \corofunction has terminated and the
incremented iterator has become invalid.\\
When a \pushcoro's \corofunction calls \cpp{iterator::operator++()} on an iterator
obtained from the \pullcoro passed by the library, control is transferred back
to the main-context. The main-context may never pass another data value. From
the \corofunction's point of view, the \cpp{iterator::operator++()} call may
never return. If it does return, the main-context has passed a new data value,
which can be accessed via \cpp{iterator::operator*()}.\\
The iterator is forward-only.\\

{\bf Example}
\cppf{input_iterator.cpp}


\subsubsection*{std::coroutine<>::push\_type}
Defined in header \cpp{<coroutine>}.\\
\begin{tabular}{ l }
    \midrule

    \cpp{template<class T> class coroutine<T>::push_type;}\\

    \midrule

    \cpp{template<class T> class coroutine<T&>::push_type;}\\

    \midrule

    \cpp{template<> class coroutine<void>::push_type;}\\

    \midrule
\end{tabular}
\newline
The class \pushcoro provides a mechanism to transfer a data value from one
execution context to another.

\paragraph*{member types\\}
\begin{tabular}{ l l l }
    \midrule

    \cpp{iterator} & std::output\_iterator & (not defined for coroutine<void>::push\_type template specialization)\\

    \midrule
\end{tabular}

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type();} & (1)\\

    \midrule

    \cpp{push_type(Function&& fn);} & (2)\\

    \midrule

    \cpp{push_type(push_type&& other);} & (3)\\

    \midrule

    \cpp{push_type(const push_type& other)=delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pushcoro which does not represent a context of
              execution
    \item[2)] creates a \pushcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pushcoro object to represent a
              context of execution that was represented by other, after this
              call other no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutines are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other] another coroutine object with which to construct this coroutine object
    \item[fn]    function to execute in the new coroutine
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2)]    \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition
\end{description}

{\bf Notes}
If the \corofunction throws an exception, this exception is re-thrown when the caller
returns from\\
\pushcoroop.\\

{\bf Example}
\cppf{access_params.cpp}

\subparagraph*{(destructor)}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~push_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pushcoro. If that \pushcoro is associated with a context of execution,
              then the context of execution is destroyed too. Specifically,
              its stack is unwound.
\end{description}

\subparagraph*{operator=}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type & operator=(push_type&& other);} & (1)\\

    \midrule

    \cpp{push_type & operator=(const push_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of other to *this using move semantics
    \item[2)] copy assignment operator is deleted; coroutines are not copyable
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{operator bool}
indicates if context of execution is still valid, that is, \corofunction has not
finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if \corofunction is not complete
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l l }
    \midrule

    \cpp{push_type & operator()(const Arg& arg);} & (1) & (member of generic template)\\

    \midrule

    \cpp{push_type & operator()(Arg&& arg);} & (2) & (member of generic template)\\

    \midrule

    \cpp{push_type & operator()(Arg& arg);} & (3) & (member only of coroutine<Arg\&>::push\_type\\
                                            &     & template specialization)\\

    \midrule

    \cpp{push_type & operator()();} & (4) & (member only of coroutine<void>::push\_type\\
                                    &     & template specialization)\\

    \midrule
\end{tabular}
\newline
Switches the context of execution, transferring arg to \corofunction. It is
important that the coroutine is valid (using \cpp{operator bool()}) befor
calling this function.

{\bf Parameters}
\begin{description}
    \item[arg] argument to pass to the \corofunction
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction
\end{description}

\subparagraph*{swap}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\paragraph*{non-member functions}
\subparagraph*{std::swap}
Specializes \cpp{std::swap} for \pushcoro and swaps the underlying context of
lhs and rhs.

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_type& lhs,push_type& rhs);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects by calling \cpp{lhs.swap(rhs)}. 
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}
\end{description}

\subparagraph*{std::begin}
Specializes \cpp{std::begin} for \pushcoro.

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::push_type::iterator begin(coroutine<R>::push_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns an \cpp{std::output_iterator}
\end{description}

\subparagraph*{std::end}
Specializes \cpp{std::end} for \pushcoro.

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::push_type::iterator end(coroutine<R>::push_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns an \cpp{std::output_iterator} indicating the termination of the coroutine
\end{description}

Incrementing the iterator switches the execution context and transfers the data value.\\
\cpp{iterator::operator++()} returns if other context has transferred control of execution back.\\
The iterator is forward-only.\\

{\bf Example}
\cppf{output_iterator.cpp}
