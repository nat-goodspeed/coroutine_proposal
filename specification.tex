\abschnitt{Technical Specification}

\subsubsection*{std::coroutine<>::pull\_type}
Defined in header \cpp{<coroutine>}.\\
\begin{tabular}{ l }
    \midrule

    \cpp{template<class T> class coroutine<T>::pull_type;}\\

    \midrule

    \cpp{template<class T> class coroutine<T&>::pull_type;}\\

    \midrule

    \cpp{template<> class coroutine<void>::pull_type;}\\

    \midrule
\end{tabular}
\newline
The class \pullcoro provides a mechanism to receive data values from
another execution context.\\

\paragraph*{member types\\}
\begin{tabular}{ l l l }
    \midrule

    \cpp{iterator} & std::input\_iterator & (not defined for coroutine<void>::pull\_type template specialization)\\

    \midrule
\end{tabular}

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type();} & (1)\\

    \midrule

    \cpp{pull_type(Function&& fn);} & (2)\\

    \midrule

    \cpp{pull_type(pull_type&& other);} & (3)\\

    \midrule

    \cpp{pull_type(const pull_type& other)=delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pullcoro which does not represent a context of execution
    \item[2)] creates a \pullcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pullcoro object to represent a
              context of execution that was represented by \textit{other}, after this
              call \textit{other} no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutines are not copyable\\
\end{description}

{\bf Notes}
\newline
Return values from the \corofunction are accessible via \pullcoroget.\\
If the \corofunction throws an exception, this exception is re-thrown when the
caller returns from\\
\pullcoroop.\\

{\bf Parameters}
\begin{description}
    \item[other]  another coroutine object with which to construct this coroutine object
    \item[fn]     function to execute in the new coroutine\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2)] \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition; re-throw user defined exceptions from \corofunction\\
\end{description}

{\bf Example}
\cppf{fibonacci.cpp}

\subparagraph*{(destructor)}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~pull_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pullcoro. If that \pullcoro is associated with a context of execution,
              then the context of execution is destroyed too. Specifically,
              its stack is unwound.\\
\end{description}

\subparagraph*{operator=}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator=(pull_type&& other);} & (1)\\

    \midrule

    \cpp{pull_type & operator=(const pull_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \textit{other} to *this using move semantics
    \item[2)] copy assignment is deleted; coroutines are not copyable\\
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object\\
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator bool}
indicates whether context of execution is still valid and a return value can be
retrieved, or \corofunction has finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine is not complete (\corofunction has
        not terminated)\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l }
    \midrule

    \cpp{pull_type & operator()();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfer control of execution to \corofunction\\
\end{description}

{\bf Notes}
\newline
It is important that the coroutine is still valid (\cpp{operator bool()}
returns \cpp{true}) before calling this function, otherwise it results in
undefined behaviour.\\

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction\\
\end{description}

\subparagraph*{get}
accesses the current value from \corofunction\\

\begin{tabular}{ l l l }
    \midrule

    \cpp{R get();} & (1) & (member of generic template)\\

    \midrule

    \cpp{R& get();} & (2) & (member of generic template)\\

    \midrule

    \cpp{void get()=delete;} & (3) & (only for coroutine<void>::pull\_type template specialization)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] access values returned from \corofunction (if move-assignable, the
              value is moved, otherwise copied)
    \item[2)] access reference returned from \corofunction\\
\end{description}

{\bf Notes}
\newline
It is important that the coroutine is still valid (\cpp{operator bool()}
returns \cpp{true}) before calling this function, otherwise it results in
undefined behaviour.\\
If type T is move-assignable, it will be returned using move semantics. With
such a type, if you call \get a second time before calling
\cpp{operator()()}, \get will throw an exception -- see below.\\

{\bf Return value}
\begin{description}
    \item[R] return type is defined by coroutine's template argument
    \item[void] coroutine does not support \get\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] Once a particular move-assignable value has already been
        retrieved by \get, any subsequent \get call throws
        \cpp{std::coroutine_error} with an error-code
        \cpp{std::coroutine_errc::no_data} until \cpp{operator()()} is called.\\
\end{description}

\subparagraph*{swap}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\paragraph*{non-member functions}
\subparagraph*{std::swap}
Specializes \cpp{std::swap} for \pullcoro and swaps the underlying context of
lhs and rhs.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(pull_type& lhs,pull_type& rhs);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects by calling \cpp{lhs.swap(rhs)}.\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{std::begin}
Specializes \cpp{std::begin} for \pullcoro.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::pull_type::iterator begin(coroutine<R>::pull_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns a \cpp{std::input_iterator}\\
\end{description}

\subparagraph*{std::end}
Specializes \cpp{std::end} for \pullcoro.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::pull_type::iterator end(coroutine<R>::pull_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns a \cpp{std::input_iterator} indicating the termination of the \corofunction\\
\end{description}

Incrementing the iterator switches the execution context.
\newline
When a main-context calls \cpp{iterator::operator++()} on an iterator obtained
from an explicitly-instantiated\\
\pullcoro, it must compare the incremented
value with the iterator returned by \cpp{std::end()}. If they are unequal, the
\corofunction has passed a new data value, which can be accessed via
\cpp{iterator::operator*()}. Otherwise the \corofunction has terminated and the
incremented iterator has become invalid.\\
When a \pushcoro's \corofunction calls \cpp{iterator::operator++()} on an iterator
obtained from the \pullcoro passed by the library, control is transferred back
to the main-context. The main-context may never pass another data value. From
the \corofunction's point of view, the \cpp{iterator::operator++()} call may
never return. If it does return, the main-context has passed a new data value,
which can be accessed via \cpp{iterator::operator*()}.\\
A function written to compare the incremented iterator with the iterator
returned by \cpp{std::end()} can be used in either situation.\\
If the return-type is move-assignable the first call to \cpp{iterator::operator*()}
moves the value. After that, any subsequent call to \cpp{iterator::operator*()} throws an
exception (\cpp{std::coroutine_error}) until \cpp{iterator::operator++()} is called.\\
The iterator is forward-only.\\

{\bf Example}
\cppf{input_iterator.cpp}


\subsubsection*{std::coroutine<>::push\_type}
Defined in header \cpp{<coroutine>}.\\
\begin{tabular}{ l }
    \midrule

    \cpp{template<class T> class coroutine<T>::push_type;}\\

    \midrule

    \cpp{template<class T> class coroutine<T&>::push_type;}\\

    \midrule

    \cpp{template<> class coroutine<void>::push_type;}\\

    \midrule
\end{tabular}
\newline
The class \pushcoro provides a mechanism to send a data value from one
execution context to another.\\

\paragraph*{member types\\}
\begin{tabular}{ l l l }
    \midrule

    \cpp{iterator} & std::output\_iterator & (not defined for coroutine<void>::push\_type template specialization)\\

    \midrule
\end{tabular}

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type();} & (1)\\

    \midrule

    \cpp{push_type(Function&& fn);} & (2)\\

    \midrule

    \cpp{push_type(push_type&& other);} & (3)\\

    \midrule

    \cpp{push_type(const push_type& other)=delete;} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \pushcoro which does not represent a context of
              execution
    \item[2)] creates a \pushcoro object and associates it with a execution
              context
    \item[3)] move constructor, constructs a \pushcoro object to represent a
              context of execution that was represented by \textit{other}, after this
              call \textit{other} no longer represents a coroutine
    \item[4)] copy constructor is deleted; coroutines are not copyable\\
\end{description}

{\bf Parameters}
\begin{description}
    \item[other] another coroutine object with which to construct this coroutine object
    \item[fn]    function to execute in the new coroutine\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1), 3)] noexcept specification: \cpp{noexcept}
    \item[2)]    \cpp{std::system_error} if the coroutine could not be started
                  - the exception may represent a implementation-specific error
                  condition\\
\end{description}

{\bf Notes}
\newline
If the \corofunction throws an exception, this exception is re-thrown when the caller
returns from\\
\pushcoroop.\\

{\bf Example}
\cppf{access_params.cpp}

\subparagraph*{(destructor)}
destructs a coroutine\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~push_type();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \pushcoro. If that \pushcoro is associated with a context of execution,
              then the context of execution is destroyed too. Specifically,
              its stack is unwound.\\
\end{description}

\subparagraph*{operator=}
moves the coroutine object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{push_type & operator=(push_type&& other);} & (1)\\

    \midrule

    \cpp{push_type & operator=(const push_type& other)=delete;} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \textit{other} to *this using move semantics
    \item[2)] copy assignment operator is deleted; coroutines are not copyable\\
\end{description}

{\bf Parameters}
\begin{description}
    \item[other]   another coroutine object to assign to this coroutine object\\
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator bool}
indicates if context of execution is still valid, that is, \corofunction has not
finished\\

\begin{tabular}{ l l }
    \midrule

    \cpp{operator bool();} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] evaluates to true if coroutine is not complete (\corofunction has
        not terminated)\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{operator()}
jump context of execution\\

\begin{tabular}{ l l l }
    \midrule

    \cpp{push_type & operator()(const Arg& arg);} & (1) & (member of generic template)\\

    \midrule

    \cpp{push_type & operator()(Arg&& arg);} & (2) & (member of generic template)\\

    \midrule

    \cpp{push_type & operator()(Arg& arg);} & (3) & (member only of coroutine<Arg\&>::push\_type\\
                                            &     & template specialization)\\

    \midrule

    \cpp{push_type & operator()();} & (4) & (member only of coroutine<void>::push\_type\\
                                    &     & template specialization)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1),2)] If \textit{Arg} is move-assignable, it will be passed using
        move semantics. Otherwise it will be copied.\\
\end{description}

Switches the context of execution, transferring \textit{arg} to \corofunction.\\

{\bf Note}
\newline
It is important that the coroutine is still valid (\cpp{operator bool()}
returns \cpp{true}) before calling this function, otherwise it results in
undefined behaviour.\\

{\bf Parameters}
\begin{description}
    \item[arg] argument to pass to the \corofunction\\
\end{description}

{\bf Return value}
\begin{description}
    \item[*this]
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] \cpp{std::system_error} if control of execution could not be
              transferred to other execution context - the exception may
              represent a implementation-specific error condition; re-throw
              user-defined exceptions from \corofunction\\
\end{description}

\subparagraph*{swap}
swaps two coroutine objects\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_type& other);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine objects\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\paragraph*{non-member functions}
\subparagraph*{std::swap}
Specializes \cpp{std::swap} for \pushcoro and swaps the underlying context of
lhs and rhs.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(push_type& lhs,push_type& rhs);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] exchanges the underlying context of execution of two coroutine
              objects by calling \cpp{lhs.swap(rhs)}.\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{std::begin}
Specializes \cpp{std::begin} for \pushcoro.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::push_type::iterator begin(coroutine<R>::push_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns a \cpp{std::output_iterator}\\
\end{description}

\subparagraph*{std::end}
Specializes \cpp{std::end} for \pushcoro.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template<class R> coroutine<R>::push_type::iterator end(coroutine<R>::push_type& c);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and returns a \cpp{std::output_iterator} indicating the termination of the coroutine\\
\end{description}

Calling \cpp{iterator::operator*(Arg&&)} switches the execution context and transfers the given data value.\\
\cpp{iterator::operator*(Arg&&)} returns if other context has transferred control of execution back.\\
The iterator is forward-only.\\

{\bf Example}
\cppf{output_iterator.cpp}


\subsubsection*{std::coroutine\_errc}
Defined in header \cpp{<coroutine>}.\\

\begin{tabular}{ l }
    \midrule

    \cpp{enum class coroutine_errc \{ no_data \};}\\

    \midrule
\end{tabular}

Enumeration \cpp{std::coroutine_errc} defines the error codes reported by
\pullcoro in\\
\cpp{std::coroutine_error} exception object.

\paragraph*{member constants}
Determines error code.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{no_data} & \pullcoro has no valid data (maybe moved by prior access)\\

    \midrule
\end{tabular}
\newline


\subsubsection*{std::coroutine\_error}
Defined in header \cpp{<coroutine>}.\\

\begin{tabular}{ l }
    \midrule

    \cpp{class coroutine_error;}\\

    \midrule
\end{tabular}

The class \cpp{std::coroutine_error} defines an exception class that is derived
from \cpp{std::logic_error}.

\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new coroutine error object.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{coroutine_error( std::error_code ec);} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates a \cpp{std::coroutine_error} error object from an error-code.\\
\end{description}

{\bf Parameters}
\begin{description}
    \item[ec] error-code
\end{description}

\subparagraph*{code}
Returns the error-code.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{const std::error_code& code() const;} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns the stored error code.\\
\end{description}

{\bf Return value}
\begin{description}
    \item[std::error\_code] stored error code\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}

\subparagraph*{what}
Returns a error-description.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{virtual const char* what() const;} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns a description of the error.\\
\end{description}

{\bf Return value}
\begin{description}
    \item[char*] null-terminated string with error description\\
\end{description}

{\bf Exceptions}
\begin{description}
    \item[1)] noexcept specification: \cpp{noexcept}\\
\end{description}
