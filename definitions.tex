\abschnitt{Definitions}
This section gives an overview about the wording used in this proposal.

\uabschnitt{Execution context}
environment where program logic is evaluated in (CPU registers, stack).

\uabschnitt{Activation record}
also known as \emph{activation frame}, \emph{control block} (\emph{stack frame}
is a special activation record).\\
An \emph{activation record} is a data structure containing the state of a
particular function call. Folowing data are part of a activation record:
\begin{itemize}
    \item a set of registers (defined by the calling convention of the ABI
        \footnote{Application Binary Interface})
    \item local variables
    \item parameters to the function
    \item eventually return value
\end{itemize}

\uabschnitt{Stack frame}
the activation records are allocated in strict last-in-first-out order on the
processor stack - placed by incrementing/decrementing the stack pointer on
function call/return.

\uabschnitt{Heap-allocated activation record}
each activation record is allocated on a separate heap. The activation record
holds a pointer to its parent activation record (parent pointer tree).

\uabschnitt{Linear stack}
is a contiguous stack and the traditional stack model of C++. The allocation,
deallocation and linkage of activation records (stack frames in this context)
are done by incrementing/decrementing the stack pointer.

\uabschnitt{Non-contiguous stack}
is a \emph{parent pointer tree}-structure used to store activation records. It
is a stack with branches, e.g. activation records can outlive the context they
were created in.

\uabschnitt{Processor stack}
is a chunk of memory into which the processor's stack pointer is pointing. The
processor stack might belong to:
\begin{itemize}
    \item an application's inital (or only) thread
    \item an explicitly-launched thread
    \item a sub-thread execution context (coroutine)
\end{itemize}

The processor stack assigned to function \main is a linear (contiguous) stack.
Often, the memory managment system is used to detect a stack overflow (and
allocate more memory). Stacks assigned to threads can not easily extended if
an overflow occurs; instead stacks with a fixed size are used - usually 1MBs
(Windows) till 2MB (Linux), but some platforms use smaller stacks (64KB on
HP-UX/PA and 256KB on HP-UX/Itanium).

\uabschnitt{Side stack}
is a call stack that is used in the case of stackful context switching, e.g.
each execution context gets its own stack (assigned to stack pointer). Thus
stack frames of subroutines are allocated on the side stack, the application
stack remains unchanged.

\uabschnitt{Linked stack}
also known as \emph{split stack}\cite{gccsplit} or
\emph{segmented stack}\cite{llvmseg}, is a non-contiguous stack, that grows on
demand. An overflow handler allocates new chunk of memory as necessary. It has a
low performance penalty - ca. 5-10\% overhead.\\
Applications compiled with support for linked stacks can use (link against)
libraries not supporting linked stacks (see GCC's documentation\cite{gccsplit},
chapter 'Backward compatibility').

\uabschnitt{Parent pointer tree}
data structure in which each node has a pointer to its parent, but no pointer to
its children. Traversion from any node to its ancestors is possible but not to
any other node.\\
Used as call stack, the structure is called \emph{cactus stack}.

\uabschnitt{Coroutine}
enables explicit suspend and resume of its progress via additional operations by
preserving execution state (\emph{activation record}) and thus provides an
enhanced control flow. Coroutines have following characteristics\cite{N3985}:
\begin{itemize}
    \item values of local data persist between successive context switches
    \item execution is suspended as control leaves coroutine and resumed at
          certain time later
    \item symmetric or asymmetric control transfer-mechanism
    \item first-class object or compiler-internal structure
    \item stackless or stackful
\end{itemize}

\uabschnitt{Toplevel context function}
is a function executed by a coroutine (stackless or stackful).

\uabschnitt{Asymmetric coroutine}
provides two distingt operations for the context switch - one operation to
resume and one operation to suspend the coroutine.\\
An asymmetric coroutine is tightly coupled with its caller, e.g. suspending the
coroutine transferes the execution control back to the point in the code were it
was called. The asymmetric control transfer-mechanism is usually used in the
context of generators.

\uabschnitt{Symmetric coroutine}
only one operation to resume/suspend the context is available.\\
A symmetric coroutine does not know its caller, e.g. the execution control can
be transfered to any other symmetric coroutine (must be explicitly specified).
The symmetric control transfer-mechanism is usually used to implement
cooperative multitasking.

\uabschnitt{Fiber/user-mode thread}
execute tasks in a cooperative multitasking environment involving a scheduler.
Coroutines and fibers are distinct (N4024\cite{N4024}).

\uabschnitt{Resumable function}
N4134\cite{N4134} describes resumable functions as an efficient language
supported mechanism for stackless context switching introducing two new keywords
- \await and \yield. Resumable functions are equivalent to asymmetric
coroutines.\\
Characteristics of resumable functions:
\begin{itemize}
    \item stackless
    \item uses heap allocated activation records (referred as activation frames
          in N4134)
    \item thight coupling between caller and resumable function (asymmetric
          control transfer-mechanism)
    \item implicit \emph{return}-statement\cite{N4134} (code transformation)
\end{itemize}
