\abschnitt{Introduction}

This proposal suggests adding two first-class, continuations to the C++ standard
library:\\
\pullcoro and \pushcoro.\\
\newline
In computer science routines are defined as a sequence of operations. The
execution of routines forms a parent-child relationship and the child terminates
always before the parent. Coroutines (the term was introduced by Melvin
Conway \cite{Conway1963}) are a generalization of routines (Donald
Knuth \cite{Knuth1997}). The principal difference between coroutines and routines
is that a coroutine enables explicit suspend and resume of its progress via
additional operations by preserving execution state and thus provides an
{\bf enhanced control flow} (maintaining the execution context).\\

\paragraph*{characteristics:}
Characteristics \cite{Moura2009} of a coroutine are:
\begin{itemize}
    \item values of local data persist between successive calls (context
          switches)
    \item execution is suspended as control leaves coroutine and resumed at
          certain time later
    \item symmetric or asymmetric control-transfer mechanism
    \item first-class object (can be passed as argument, returned by procedures,
          stored in a data structure to be used later or freely manipulated by
          the developer)
    \item stackful or stackless
\end{itemize}

Several programming languages adopted particular features (C\# yield, Python
generators, ...).
\begin{table}[h]
    \centering
    \begin{tabular}{ l l l l l l }
        \midrule
        BCPL    &   Erlang  &   Go      &   Lua         &   PHP     &   Ruby\\
        \midrule
        C\#     &   F\#     &   Haskell &   Modula-2    &   Prolog  &   Sather\\
        \midrule
        D       &   Factor  &   Icon    &   Perl        &   Python  &   Scheme\\
        \midrule
    \end{tabular}
    \caption{some programming languages with native support of coroutines
        \cite{wikipedia}}
\end{table}
\newline
Coroutines are useful in simulation, artificial intelligence, concurrent
programming, text processing and data manipulation \cite{Moura2009}, supporting
the implementation of components such as cooperative tasks (fibers), iterators,
generators, infinite lists, pipes etc.

\paragraph*{execution-transfer mechanism:}
Two categories of coroutines exist: symmetric and asymmetric coroutines.\\
\newline
A symmetric coroutine transfers the execution control only via one operation.
The target coroutine must be explicitly specified in the transfer operation.\\
\newline
Asymmetric coroutines provide two transfer operations:
the \textit{suspend}-operation returns to the invoker by preserving the
execution context  and the \textit{resume}-operation restores the execution
context, e.g. re-enters the coroutine at the same point as it was suspended
before.
\imgc{sequence.pdf}
Both concepts are equivalent and a coroutine library can provide either
symmetric or asymmetric coroutines \cite{Moura2009}.

\paragraph*{stackfulness:}
In contrast to a stackless coroutine a stackful coroutine allows to suspend
from nested stackframes. The execution resumes at exact the same point in the
code as it was suspended before.\\
With a stackless coroutine, only the top-level routine may be suspended. Any
routine called by that top-level routine may not itself suspend. This prohibits
providing suspend/resume operations in routines within a general-purpose library.

\paragraph*{first-class continuation:}
A first-class continuation can be passed as argument, returned by
function and stored in a data structure to be used later.\\
In some implementations (for instance C\# \textit{yield}) the continuation can
not directly accessed or directly manipulated.\\
\newline
Without stackfulness and first-class semantics some useful execution control
flows cannot be supported (for instance cooperative multitasking or
checkpointing).
