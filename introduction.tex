\abschnitt{Introduction}

This proposal suggests adding two first-class continuations to the C++ standard
library:\\
\pullcoro and \pushcoro.\\
\newline
In computer science routines are defined as a sequence of operations. The
execution of routines forms a parent-child relationship and the child terminates
always before the parent. Coroutines (the term was introduced by Melvin
Conway \cite{Conway1963}) are a generalization of routines (Donald
Knuth \cite{Knuth1997}). The principal difference between coroutines and routines
is that a coroutine enables explicit suspend and resume of its progress via
additional operations by preserving execution state and thus provides an
{\bf enhanced control flow} (maintaining the execution context).\\

\paragraph*{characteristics:}
Characteristics \cite{Moura2009} of a coroutine are:
\begin{itemize}
    \item values of local data persist between successive calls (context
          switches)
    \item execution is suspended as control leaves coroutine and resumed at
          certain time later
    \item symmetric or asymmetric control-transfer mechanism
    \item first-class object (can be passed as argument, returned by procedures,
          stored in a data structure to be used later or freely manipulated by
          the developer)
    \item stackful or stackless
\end{itemize}

Several programming languages adopted particular features (C\# yield, Python
generators, ...).
\begin{table}[h]
    \centering
    \begin{tabular}{ l l l l l l }
        \midrule
        BCPL    &   Erlang  &   Go      &   Lua         &   PHP     &   Ruby\\
        \midrule
        C\#     &   F\#     &   Haskell &   Modula-2    &   Prolog  &   Sather\\
        \midrule
        D       &   Factor  &   Icon    &   Perl        &   Python  &   Scheme\\
        \midrule
    \end{tabular}
    \caption{some programming languages with native support of coroutines
        \cite{wikipedia}}
\end{table}
\newline
Coroutines are useful in simulation, artificial intelligence, concurrent
programming, text processing and data manipulation \cite{Moura2009}, supporting
the implementation of components such as cooperative tasks (fibers), iterators,
generators, infinite lists, pipes etc.

\paragraph*{execution-transfer mechanism:}
Two categories of coroutines exist: symmetric and asymmetric coroutines.\\
\newline
A symmetric coroutine transfers the execution control only via one operation.
The target coroutine must be explicitly specified in the transfer operation.\\
\newline
Asymmetric coroutines provide two transfer operations.
The \textit{suspend}-operation returns to the invoker by preserving the
execution context and the \textit{resume}-operation restores the execution
context: control re-enters the coroutine at the point at which it was suspended.
\imgc{sequence.pdf}
Both concepts are equivalent and a coroutine library can provide either
symmetric or asymmetric coroutines \cite{Moura2009}.

\paragraph*{stackfulness:}
In contrast to a stackless coroutine a stackful coroutine allows to suspend
from nested stackframes. The execution resumes at the exact same point in the
code as it was suspended before.\\
With a stackless coroutine, only the top-level routine may be suspended. Any
routine called by that top-level routine may not itself suspend. This prohibits
providing suspend/resume operations in routines within a general-purpose library.

\paragraph*{first-class continuation:}
A first-class continuation can be passed as an argument, returned by a
function and stored in a data structure to be used later.\\
In some implementations (for instance C\# \textit{yield}) the continuation can
not be directly accessed or directly manipulated.\\
\newline
Without stackfulness and first-class semantics some useful execution control
flows cannot be supported (for instance cooperative multitasking or
checkpointing).

\paragraph*{What coroutines actually do:}
Coroutines are generalized routines.\\
\newline
A routine has a parent-child relationship to its sub-routines.\\
The routine processes (push to stack or store in registers) the arguments which
have to be paased as parameters to the sub-routine as it is defined in the \cv
of the underlying \ABI. A \textit{branch-and-link} instruction transfers
execution control to the code of the sub-routine.\\
If the sub-routine is entered the \textit{prolog} creates a new stack frame
(adjusting the stack-pointer and/or frame-pointer), preserves some
non-volatile general purpose registers (as defined by the \cv) and return
address. Space for local variables is allocated by modifying the
stack-pointer.\\
If a sub-routine  finishes, it runs the \textit{epilog} which undoes the steps
from the \textit{prolog}, e.g. it restore preserved registers, remove the
stack-frame (stack-pointer is set to address before the sub-routine was entered),
and branch to the instruction at the return address.\\
A return value might be returned in a register defined by the \cv.\\
\newline
Coroutines execute the same steps as ordinary routines. The main difference is 
that each coroutine owns its own stack, e.g. if a coroutine is suspended its
stackframe is not removed. This fact is the reason why coroutines allow to
re-enter the same stackframe several times.\\
A coroutine contains a control-block which is used as a storage for
stack-pointer, instruction-pointer and some general purpose registers.
Coroutines manipulate those registers directly (done by calling
\textit{suspend}/\textit{resume}).\\
\newline
Oridinary routines are a subset of coroutines in the case of a coroutine which
does not suspend and runs straight to its end (finishes execution).\\
\newline
In fact entering a coroutines is equivalent to entering an ordinary routine, but
they provide a enhanced control flow.
