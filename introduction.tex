\abschnitt{Introduction}

This proposal suggests adding two first-class continuations to the C++ standard
library:\\
\pullcoro and \pushcoro.\\
\newline
In computer science routines are defined as a sequence of operations. The
execution of routines forms a parent-child relationship and the child terminates
always before the parent. Coroutines (the term was introduced by Melvin
Conway \cite{Conway1963}) are a generalization of routines (Donald
Knuth \cite{Knuth1997}). The principal difference between coroutines and routines
is that a coroutine enables explicit suspend and resume of its progress via
additional operations by preserving execution state and thus provides an
{\bf enhanced control flow} (maintaining the execution context).\\

\paragraph*{characteristics:}
Characteristics \cite{Moura2009} of a coroutine are:
\begin{itemize}
    \item values of local data persist between successive calls (context
          switches)
    \item execution is suspended as control leaves coroutine and resumed at
          certain time later
    \item symmetric or asymmetric control-transfer mechanism
    \item first-class object (can be passed as argument, returned by procedures,
          stored in a data structure to be used later or freely manipulated by
          the developer)
    \item stackful or stackless
\end{itemize}

Several programming languages adopted particular features (C\# yield, Python
generators, ...).
\begin{table}[h]
    \centering
    \begin{tabular}{ l l l l l l }
        \midrule
        BCPL    &   Erlang  &   Go      &   Lua         &   PHP     &   Ruby\\
        \midrule
        C\#     &   F\#     &   Haskell &   Modula-2    &   Prolog  &   Sather\\
        \midrule
        D       &   Factor  &   Icon    &   Perl        &   Python  &   Scheme\\
        \midrule
    \end{tabular}
    \caption{some programming languages with native support of coroutines
        \cite{wikipedia}}
\end{table}
\newline
Coroutines are useful in simulation, artificial intelligence, concurrent
programming, text processing and data manipulation \cite{Moura2009}, supporting
the implementation of components such as cooperative tasks (fibers), iterators,
generators, infinite lists, pipes etc.

\paragraph*{execution-transfer mechanism:}
Two categories of coroutines exist: symmetric and asymmetric coroutines.\\
\newline
A symmetric coroutine transfers the execution control only via one operation.
The target coroutine must be explicitly specified in the transfer operation.\\
\newline
Asymmetric coroutines provide two transfer operations.
The \textit{suspend}-operation returns to the invoker by preserving the
execution context and the \textit{resume}-operation restores the execution
context: control re-enters the coroutine at the point at which it was suspended.
\imgc{sequence.pdf}
Both concepts are equivalent and a coroutine library can provide either
symmetric or asymmetric coroutines \cite{Moura2009}.

\paragraph*{stackfulness:}
In contrast to a stackless coroutine a stackful coroutine allows to suspend
from nested stackframes. The execution resumes at the exact same point in the
code as it was suspended before.\\
With a stackless coroutine, only the top-level routine may be suspended. Any
routine called by that top-level routine may not itself suspend. This prohibits
providing suspend/resume operations in routines within a general-purpose library.

\paragraph*{first-class continuation:}
A first-class continuation can be passed as an argument, returned by a
function and stored in a data structure to be used later.\\
In some implementations (for instance C\# \textit{yield}) the continuation can
not be directly accessed or directly manipulated.\\
\newline
Without stackfulness and first-class semantics some useful execution control
flows cannot be supported (for instance cooperative multitasking or
checkpointing).

\paragraph*{What coroutines actually do:}
Coroutines are generalized routines.\\
\newline
A routine has a parent-child relationship to its subroutines.\\
The routine processes (pushes to stack or stores in registers) the arguments which
have to be passed as parameters to the subroutine as it is defined in the \cv
of the underlying \ABI. A \textit{branch-and-link} instruction transfers
execution control to the code of the subroutine.\\
When the subroutine is entered the \textit{prolog} creates a new stack frame
(adjusting the stack-pointer and/or frame-pointer), preserves some
non-volatile general purpose registers (as defined by the \cv) and return
address. Space for local variables is allocated by modifying the
stack-pointer.\\
When a subroutine  finishes, it runs the \textit{epilog} which undoes the steps
from the \textit{prolog}, e.g. it restores preserved registers, removes the
stack-frame (stack-pointer is restored to address before the subroutine was entered),
and branches to the instruction at the return address.\\
A return value might be returned in a register defined by the \cv.\\
\newline
When a coroutine switches execution context it executes the same as
ordinary routines: saving and restoring some CPU registers. The main
difference is that each coroutine owns its own stack, that is, when a coroutine is
suspended its stackframe is not removed. This fact is the reason why a coroutine
allows you to re-enter the same stackframe several times.\\ A coroutine contains a
\cblock which is used as a storage for the stack-pointer, instruction-pointer and
some general purpose registers.\\ Coroutines manipulate those registers directly
(done by calling \textit{suspend}/\textit{resume}).\\
Appendix \nameref{appendix} shows for x86\_64/SYSV ABI how a
\textit{jump}-operation could be implemented.
\newline
Oridinary routines are a subset of coroutines in the case of a coroutine which
does not suspend and runs straight to its end (finishes execution).\\
\newline
In fact entering a coroutine is equivalent to entering an ordinary routine, but
it provides enhanced control flow.
