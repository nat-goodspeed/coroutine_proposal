\abschnitt{Introduction}
Traditionally C++ code is compiled for a linear stack, that means that the
activation records are allocated in strict \emph{last-in-first-out}-order. This
stack model allocates activation records on function call/return by
incrementing/decrementing the stack pointer.\\
Coroutines enable a more advanced control flow. That requires, that a coroutine
outlives the context in which it was created (the activation record of a
suspended coroutine {\bfseries must not} be {\bfseries removed})! Additionally,
if the activation record of a suspended coroutine remains on the linear
processor stack and other code uses the stack in the meanwhile, then all stack
frames allocated after suspending the coroutine might have been corrupted
(overwritten).\\
Traditional stack management is inadequate for coroutines.\\
\newline
N4397\cite{N4397} describes the \emph{first-class} construct \ectx, representing
a execution state. A program contains at least one execution context. As
explained in N4397, \ectx can be used to implement stackful coroutines as
proposed in N3985\cite{N3985} or might be the building block of \emph{oneshot
shift/reset}-operators.\\
In the remaining chapters the proposal describes under which constraints \ectx
can be used for stackless and stackful context switching.
